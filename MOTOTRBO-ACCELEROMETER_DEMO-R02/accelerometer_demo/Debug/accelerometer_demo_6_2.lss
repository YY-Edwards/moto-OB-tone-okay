
accelerometer_demo_6_2.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80010000  80010000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000019fc  80012008  80012008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .exception    00000200  80013c00  80013c00  00004000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000ac  80013e00  80013e00  00004200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .lalign       00000004  80013eac  80013eac  000042ac  2**0
                  ALLOC
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .bss          00004940  00000008  00000008  00000000  2**2
                  ALLOC
  7 .heap         000026b8  00004948  00004948  00000000  2**0
                  ALLOC
  8 .comment      00000030  00000000  00000000  000042ac  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000001d8  00000000  00000000  000042e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000004a6  00000000  00000000  000044b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00004fa0  00000000  00000000  0000495e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000005a0  00000000  00000000  000098fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00000a12  00000000  00000000  00009e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000434  00000000  00000000  0000a8b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001bf4  00000000  00000000  0000ace4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    000007c7  00000000  00000000  0000c8d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00007000  00007000  00000000  2**0
                  ALLOC
 18 .debug_ranges 00000180  00000000  00000000  0000d0a0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80010000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80010000:	fe cf c6 38 	sub	pc,pc,-14792

80010004 <_trampoline>:
80010004:	e0 8f 10 00 	bral	80012004 <program_start>
	...

80012004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80012004:	fe cf e6 3c 	sub	pc,pc,-6596

Disassembly of section .text:

80012008 <_get_interrupt_handler>:
80012008:	48 28       	lddpc	r8,80012010 <_get_interrupt_handler+0x8>
8001200a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]

//Gets the interrupt handler of the current int_lev
__int_handler _get_interrupt_handler(unsigned int int_lev)
{
	return interrupt_priority_handlers[int_lev];
}
8001200e:	5e fc       	retal	r12
80012010:	80 01       	ld.sh	r1,r0[0x0]
80012012:	3e 00       	mov	r0,-32

80012014 <my_init_interrupts>:

void my_init_interrupts(void)
{
80012014:	d4 01       	pushm	lr
80012016:	48 b9       	lddpc	r9,80012040 <my_init_interrupts+0x2c>
80012018:	30 08       	mov	r8,0
    {
    	AVR32_INTC.ipr[int_grp] = ipr_val[requestedPriority];
    }
    else
    {
    	AVR32_INTC.ipr[int_grp] = 0x00000000; //Zero Offset from _evba is unrecoverable.
8001201a:	fe 7b 08 00 	mov	r11,-63488
8001201e:	10 9e       	mov	lr,r8
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    requestedPriority = priorityMapping[int_grp];
    if (requestedPriority >= 0)
    {
    	AVR32_INTC.ipr[int_grp] = ipr_val[requestedPriority];
80012020:	48 9c       	lddpc	r12,80012044 <my_init_interrupts+0x30>
  int requestedPriority;

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    requestedPriority = priorityMapping[int_grp];
80012022:	72 0a       	ld.w	r10,r9[0x0]
    if (requestedPriority >= 0)
80012024:	58 0a       	cp.w	r10,0
80012026:	c0 65       	brlt	80012032 <my_init_interrupts+0x1e>
    {
    	AVR32_INTC.ipr[int_grp] = ipr_val[requestedPriority];
80012028:	f8 0a 03 2a 	ld.w	r10,r12[r10<<0x2]
8001202c:	f6 08 09 2a 	st.w	r11[r8<<0x2],r10
80012030:	c0 38       	rjmp	80012036 <my_init_interrupts+0x22>
    }
    else
    {
    	AVR32_INTC.ipr[int_grp] = 0x00000000; //Zero Offset from _evba is unrecoverable.
80012032:	f6 08 09 2e 	st.w	r11[r8<<0x2],lr
{
  unsigned int int_grp;
  int requestedPriority;

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80012036:	2f f8       	sub	r8,-1
80012038:	2f c9       	sub	r9,-4
8001203a:	59 38       	cp.w	r8,19
8001203c:	cf 31       	brne	80012022 <my_init_interrupts+0xe>
    else
    {
    	AVR32_INTC.ipr[int_grp] = 0x00000000; //Zero Offset from _evba is unrecoverable.
    }
  }
}
8001203e:	d8 02       	popm	pc
80012040:	80 01       	ld.sh	r1,r0[0x0]
80012042:	3e 60       	mov	r0,-26
80012044:	80 01       	ld.sh	r1,r0[0x0]
80012046:	3d 3c       	mov	r12,-45

80012048 <reset_IsFillingNextU16>:
  RxCirBuffer theRxCirBuffer;
  phy_block TxBufferPool[TXPOOLSIZE];

  void reset_IsFillingNextU16(void)
  {
	  theRxCirCtrlr.RxXNL_IsFillingNextU16 =
80012048:	48 48       	lddpc	r8,80012058 <reset_IsFillingNextU16+0x10>
8001204a:	f1 09 00 10 	ld.sh	r9,r8[16]
8001204e:	a7 79       	lsl	r9,0x7
80012050:	f1 59 00 12 	st.h	r8[18],r9
		  theRxCirCtrlr.RxXNL_IsFillingMessageIndex << 7;
  }
80012054:	5e fc       	retal	r12
80012056:	00 00       	add	r0,r0
80012058:	00 00       	add	r0,r0
8001205a:	38 38       	mov	r8,-125

8001205c <post_message>:

  void post_message(void)
  {
	  S16 nextpossiblebufferindex;

	  nextpossiblebufferindex = ((theRxCirCtrlr.RxXNL_IsFillingMessageIndex) + 1) & RXCIRBUFFERFRAGWRAP;
8001205c:	48 88       	lddpc	r8,8001207c <post_message+0x20>
8001205e:	f1 09 00 10 	ld.sh	r9,r8[16]
80012062:	2f f9       	sub	r9,-1
80012064:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
	  if ( nextpossiblebufferindex
80012068:	f1 08 00 14 	ld.sh	r8,r8[20]
8001206c:	f2 08 19 00 	cp.h	r8,r9
80012070:	5e 0c       	reteq	r12
		!= theRxCirCtrlr.RxXNL_ProcessWaitingIndex ){ //Test for collision, discard.
		  theRxCirCtrlr.RxXNL_IsFillingMessageIndex =
80012072:	48 38       	lddpc	r8,8001207c <post_message+0x20>
80012074:	f1 59 00 10 	st.h	r8[16],r9
80012078:	5e fc       	retal	r12
8001207a:	00 00       	add	r0,r0
8001207c:	00 00       	add	r0,r0
8001207e:	38 38       	mov	r8,-125

80012080 <XNL_PhyRx>:
			  nextpossiblebufferindex;
	  }
  }

  void XNL_PhyRx(U32 theXNLRxWord)
  {
80012080:	d4 01       	pushm	lr
		//This is the code for parsing the incoming physical message.
	    switch (theRxCirCtrlr.theRxLink_State){
80012082:	4e 58       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
80012084:	70 28       	ld.w	r8,r8[0x8]
80012086:	58 18       	cp.w	r8,1
80012088:	c5 10       	breq	8001212a <XNL_PhyRx+0xaa>
8001208a:	c0 83       	brcs	8001209a <XNL_PhyRx+0x1a>
8001208c:	58 28       	cp.w	r8,2
8001208e:	e0 80 00 90 	breq	800121ae <XNL_PhyRx+0x12e>
80012092:	58 38       	cp.w	r8,3
80012094:	e0 81 00 be 	brne	80012210 <XNL_PhyRx+0x190>
80012098:	ca 98       	rjmp	800121ea <XNL_PhyRx+0x16a>

	    // Note that all segments must align with a 32-bit boundary and beginning of
	    // each XCMP/XNL payload frame must start on slot 3 Thus, segments of odd length
	    // must append a 0x0000 at the end (slot 4) to ensure alignment. [9.1.3]
	    case WAITINGFORHEADER:                  //Waiting for something. Most frequent visit.
	    	if (0xABCD5A5A == theXNLRxWord)   break;                   //Ignore Idles.
8001209a:	e0 69 5a 5a 	mov	r9,23130
8001209e:	ea 19 ab cd 	orh	r9,0xabcd
800120a2:	12 3c       	cp.w	r12,r9
800120a4:	e0 80 00 b6 	breq	80012210 <XNL_PhyRx+0x190>
	    	if (0xABCD0000 != (theXNLRxWord  & 0xFFFF0000)) break;   //Skip until Header.
800120a8:	18 98       	mov	r8,r12
800120aa:	e0 18 00 00 	andl	r8,0x0
800120ae:	fc 19 ab cd 	movh	r9,0xabcd
800120b2:	12 38       	cp.w	r8,r9
800120b4:	e0 81 00 ae 	brne	80012210 <XNL_PhyRx+0x190>
	    	if (0x00004000 != (theXNLRxWord  & 0x0000F000)) break;   //Skip non-XCMPXNL_DATA.
800120b8:	18 98       	mov	r8,r12
800120ba:	e2 18 f0 00 	andl	r8,0xf000,COH
800120be:	e0 48 40 00 	cp.w	r8,16384
800120c2:	e0 81 00 a7 	brne	80012210 <XNL_PhyRx+0x190>
                
    //           AVR32_GPIO.port[1].ovrc  =  0x00000008;
			
			theRxCirCtrlr.RxLink_Expected = (theXNLRxWord & 0x000000FF) - 2; //Length excluding CSUM.
800120c6:	f3 dc b0 10 	bfexts	r9,r12,0x0,0x10
800120ca:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800120ce:	20 28       	sub	r8,2
800120d0:	4d 1a       	lddpc	r10,80012214 <XNL_PhyRx+0x194>
800120d2:	b4 68       	st.h	r10[0xc],r8
	    	if (theRxCirCtrlr.RxLink_Expected <= 0) break;           //Discard degenerate message.
800120d4:	30 0a       	mov	r10,0
800120d6:	f4 08 19 00 	cp.h	r8,r10
800120da:	e0 8a 00 9b 	brle	80012210 <XNL_PhyRx+0x190>
	    	//Do not need to check for buffer wrap here. Should point to clean buffer.
	    	theRxCirBuffer.CirBufferElement16[(theRxCirCtrlr.RxXNL_IsFillingNextU16)++] = theXNLRxWord;
800120de:	4c e8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800120e0:	f1 0b 00 12 	ld.sh	r11,r8[18]
800120e4:	4c da       	lddpc	r10,80012218 <XNL_PhyRx+0x198>
800120e6:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800120ea:	f6 c9 ff ff 	sub	r9,r11,-1
800120ee:	5c 89       	casts.h	r9
	    	theRxCirBuffer.CirBufferElement16[(theRxCirCtrlr.RxXNL_IsFillingNextU16)++] = (theRxCirCtrlr.RxLinkCount) & 0x0000FFFF; //Time stamp.
800120f0:	70 0b       	ld.w	r11,r8[0x0]
800120f2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800120f6:	2f f9       	sub	r9,-1
800120f8:	f1 59 00 12 	st.h	r8[18],r9

	        //This switch tests the fragment type, and adjusts receiver state accordingly.
	        switch (theXNLRxWord & 0x00000F00) {  //Check frag type.
800120fc:	e2 1c 0f 00 	andl	r12,0xf00,COH
80012100:	e0 4c 01 00 	cp.w	r12,256
80012104:	c0 c0       	breq	8001211c <XNL_PhyRx+0x9c>
80012106:	e0 8b 00 05 	brhi	80012110 <XNL_PhyRx+0x90>
8001210a:	58 0c       	cp.w	r12,0
8001210c:	c0 80       	breq	8001211c <XNL_PhyRx+0x9c>
8001210e:	c0 b8       	rjmp	80012124 <XNL_PhyRx+0xa4>
80012110:	e0 4c 02 00 	cp.w	r12,512
80012114:	c0 40       	breq	8001211c <XNL_PhyRx+0x9c>
80012116:	e0 4c 03 00 	cp.w	r12,768
8001211a:	c0 51       	brne	80012124 <XNL_PhyRx+0xa4>
	        case 0x00000000:                      //Only Fragment.
	        case 0x00000100:                      //First of Multifragment.
	        case 0x00000200:                      //Continuing Multifragment.
	        case 0x00000300:                      //Last Multifragment.
	        	theRxCirCtrlr.theRxLink_State = WAITINGCSUM;
8001211c:	30 29       	mov	r9,2
8001211e:	4b e8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
80012120:	91 29       	st.w	r8[0x8],r9
	        	break;
80012122:	d8 02       	popm	pc
	        default:                              //No other values allowed.
	        	reset_IsFillingNextU16();
80012124:	f0 1f 00 3e 	mcall	8001221c <XNL_PhyRx+0x19c>
80012128:	d8 02       	popm	pc
	        }
	        break;


	    case READINGFRAGMENT:
	    	  theRxCirBuffer.CirBufferElement16[(theRxCirCtrlr.RxXNL_IsFillingNextU16)++] = (theXNLRxWord & 0xFFFF0000) >> 16;
8001212a:	4b b8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
8001212c:	f1 09 00 12 	ld.sh	r9,r8[18]
80012130:	f8 0a 14 10 	asr	r10,r12,0x10
80012134:	4b 9b       	lddpc	r11,80012218 <XNL_PhyRx+0x198>
80012136:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8001213a:	2f f9       	sub	r9,-1
8001213c:	5c 89       	casts.h	r9
8001213e:	f1 59 00 12 	st.h	r8[18],r9
	    	  theRxCirCtrlr.RxLink_CSUM += (theXNLRxWord & 0xFFFF0000) >> 16;
80012142:	90 7b       	ld.sh	r11,r8[0xe]
80012144:	f6 0a 00 0a 	add	r10,r11,r10
80012148:	f7 da b0 10 	bfexts	r11,r10,0x0,0x10
8001214c:	b0 7b       	st.h	r8[0xe],r11
	    	  theRxCirCtrlr.RxLink_Expected -= 2;
8001214e:	90 6e       	ld.sh	lr,r8[0xc]
80012150:	20 2e       	sub	lr,2
80012152:	5c 8e       	casts.h	lr
80012154:	f5 de b0 10 	bfexts	r10,lr,0x0,0x10
80012158:	b0 6a       	st.h	r8[0xc],r10
	    	  if (theRxCirCtrlr.RxLink_Expected <= 0) {
8001215a:	30 08       	mov	r8,0
8001215c:	f0 0a 19 00 	cp.h	r10,r8
80012160:	e0 89 00 11 	brgt	80012182 <XNL_PhyRx+0x102>
	    		  //All read in.
	    		  //Terminator should be in 2nd hWord.
	    		  //Shaoqun says useful bits not used. The packet will always end with $00BA. [9.1.2.8]
	    		  if ( (0x000000BA == (theXNLRxWord  & 0x0000FFFF))
80012164:	f9 dc c0 10 	bfextu	r12,r12,0x0,0x10
80012168:	e0 4c 00 ba 	cp.w	r12,186
8001216c:	c0 51       	brne	80012176 <XNL_PhyRx+0xf6>
8001216e:	58 0b       	cp.w	r11,0
80012170:	c0 31       	brne	80012176 <XNL_PhyRx+0xf6>
	    			  && (theRxCirCtrlr.RxLink_CSUM == 0)  )  {
	    			  post_message();
80012172:	f0 1f 00 2c 	mcall	80012220 <XNL_PhyRx+0x1a0>
	    		  }
	    		  reset_IsFillingNextU16();
80012176:	f0 1f 00 2a 	mcall	8001221c <XNL_PhyRx+0x19c>
	    		  theRxCirCtrlr.theRxLink_State = WAITINGFORHEADER;
8001217a:	30 09       	mov	r9,0
8001217c:	4a 68       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
8001217e:	91 29       	st.w	r8[0x8],r9
	    		  break;
80012180:	d8 02       	popm	pc
	    	  }

	    	  //Have not broken. 2nd hWord contains payload.
	    	  theRxCirBuffer.CirBufferElement16[(theRxCirCtrlr.RxXNL_IsFillingNextU16)++] = (theXNLRxWord & 0x0000FFFF);
80012182:	4a 68       	lddpc	r8,80012218 <XNL_PhyRx+0x198>
80012184:	f0 09 0a 1c 	st.h	r8[r9<<0x1],r12
80012188:	4a 38       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
8001218a:	2f f9       	sub	r9,-1
8001218c:	f1 59 00 12 	st.h	r8[18],r9
	    	  theRxCirCtrlr.RxLink_CSUM  += (theXNLRxWord & 0x0000FFFF);
80012190:	f6 0c 00 0c 	add	r12,r11,r12
80012194:	b0 7c       	st.h	r8[0xe],r12
	    	  theRxCirCtrlr.RxLink_Expected -= 2;
80012196:	20 2e       	sub	lr,2
80012198:	5c 8e       	casts.h	lr
8001219a:	b0 6e       	st.h	r8[0xc],lr
	    	  if (theRxCirCtrlr.RxLink_Expected <= 0) {
8001219c:	30 08       	mov	r8,0
8001219e:	f0 0e 19 00 	cp.h	lr,r8
800121a2:	e0 89 00 37 	brgt	80012210 <XNL_PhyRx+0x190>
	    		  //All read in. Next Word should be 0x00BA0000.
	    		  theRxCirCtrlr.theRxLink_State = WAITINGLASTTERM;
800121a6:	30 39       	mov	r9,3
800121a8:	49 b8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800121aa:	91 29       	st.w	r8[0x8],r9
800121ac:	d8 02       	popm	pc



	    case WAITINGCSUM:   //Gets here on CSUM. Expect at least one hWord payload. Gets here once on every fragment.
	    	theRxCirCtrlr.RxLink_CSUM  = (theXNLRxWord & 0xFFFF0000) >> 16;  //Stores CSUM
	    	theRxCirCtrlr.RxLink_CSUM += (theXNLRxWord & 0x0000FFFF);        //sums in first hWord
800121ae:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800121b2:	49 98       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800121b4:	b1 8c       	lsr	r12,0x10
800121b6:	14 0c       	add	r12,r10
800121b8:	b0 7c       	st.h	r8[0xe],r12
	    	theRxCirBuffer.CirBufferElement16[(theRxCirCtrlr.RxXNL_IsFillingNextU16)++] = (theXNLRxWord & 0x0000FFFF);
800121ba:	f1 09 00 12 	ld.sh	r9,r8[18]
800121be:	49 7b       	lddpc	r11,80012218 <XNL_PhyRx+0x198>
800121c0:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800121c4:	2f f9       	sub	r9,-1
800121c6:	f1 59 00 12 	st.h	r8[18],r9
	    	theRxCirCtrlr.RxLink_Expected -= 2;
800121ca:	90 69       	ld.sh	r9,r8[0xc]
800121cc:	20 29       	sub	r9,2
800121ce:	b0 69       	st.h	r8[0xc],r9
	    	if (theRxCirCtrlr.RxLink_Expected > 0) { //Normal case for greater than one byte payloads.
800121d0:	30 08       	mov	r8,0
800121d2:	f0 09 19 00 	cp.h	r9,r8
800121d6:	e0 8a 00 06 	brle	800121e2 <XNL_PhyRx+0x162>
	    		theRxCirCtrlr.theRxLink_State = READINGFRAGMENT;
800121da:	30 19       	mov	r9,1
800121dc:	48 e8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800121de:	91 29       	st.w	r8[0x8],r9
800121e0:	d8 02       	popm	pc
	    	}else{ //Sort of strange, one byte payload. Should not happen, but follow protocol.
	    		  	//Expect next word 0x00BA0000.
	    			//Note that all segments must align with a 32-bit boundary and beginning
	    			//of each XCMP/XNL payload frame must start on slot 3 Thus, segments
	    			//of odd length must append a 0x0000 at the end (slot 4) to ensure alignment. [9.1.3]
	    			theRxCirCtrlr.theRxLink_State = WAITINGLASTTERM;
800121e2:	30 39       	mov	r9,3
800121e4:	48 c8       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800121e6:	91 29       	st.w	r8[0x8],r9
800121e8:	d8 02       	popm	pc
	    	break;



	    case WAITINGLASTTERM:     //Expecting last terminator 0x00BA0000.
	    	if (  (0x00BA0000 == (theXNLRxWord  & 0x00FF0000)) //Expected found.
800121ea:	e6 1c 00 ff 	andh	r12,0xff,COH
800121ee:	fc 18 00 ba 	movh	r8,0xba
800121f2:	10 3c       	cp.w	r12,r8
800121f4:	c0 91       	brne	80012206 <XNL_PhyRx+0x186>
800121f6:	48 88       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
800121f8:	90 79       	ld.sh	r9,r8[0xe]
800121fa:	30 08       	mov	r8,0
800121fc:	f0 09 19 00 	cp.h	r9,r8
80012200:	c0 31       	brne	80012206 <XNL_PhyRx+0x186>
	    	   &&  (theRxCirCtrlr.RxLink_CSUM == 0)  ) {       //Good checksum.
	    		post_message();
80012202:	f0 1f 00 08 	mcall	80012220 <XNL_PhyRx+0x1a0>
	    	}
	    	theRxCirCtrlr.theRxLink_State = WAITINGFORHEADER;
80012206:	30 09       	mov	r9,0
80012208:	48 38       	lddpc	r8,80012214 <XNL_PhyRx+0x194>
8001220a:	91 29       	st.w	r8[0x8],r9
	    	reset_IsFillingNextU16();
8001220c:	f0 1f 00 04 	mcall	8001221c <XNL_PhyRx+0x19c>
80012210:	d8 02       	popm	pc
80012212:	00 00       	add	r0,r0
80012214:	00 00       	add	r0,r0
80012216:	38 38       	mov	r8,-125
80012218:	00 00       	add	r0,r0
8001221a:	28 38       	sub	r8,-125
8001221c:	80 01       	ld.sh	r1,r0[0x0]
8001221e:	20 48       	sub	r8,4
80012220:	80 01       	ld.sh	r1,r0[0x0]
80012222:	20 5c       	sub	r12,5

80012224 <XNL_PhyTx>:
	    }//End of theRxLink_State switch.
  }


  U32 XNL_PhyTx(void)
  {
80012224:	d4 01       	pushm	lr
	  U32 theReturn;
    //This is the code for handling any outgoing XNL Phy message.
    switch (txSchedule.TxLinkState){
80012226:	4d c8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012228:	70 28       	ld.w	r8,r8[0x8]
8001222a:	58 18       	cp.w	r8,1
8001222c:	c2 a0       	breq	80012280 <XNL_PhyTx+0x5c>
8001222e:	c0 83       	brcs	8001223e <XNL_PhyTx+0x1a>
80012230:	58 28       	cp.w	r8,2
80012232:	e0 80 00 9b 	breq	80012368 <XNL_PhyTx+0x144>
80012236:	58 38       	cp.w	r8,3
80012238:	e0 81 00 ad 	brne	80012392 <XNL_PhyTx+0x16e>
8001223c:	c7 38       	rjmp	80012322 <XNL_PhyTx+0xfe>
    case IDLEWAITINGSCHEDULE:
    	//Test to see if there is anything to transmit.
    	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){ //Nothing new to transmit. Send Idle.
8001223e:	4d 68       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012240:	70 79       	ld.w	r9,r8[0x1c]
80012242:	58 49       	cp.w	r9,4
80012244:	c0 61       	brne	80012250 <XNL_PhyTx+0x2c>
80012246:	e0 6c 5a 5a 	mov	r12,23130
8001224a:	ea 1c ab cd 	orh	r12,0xabcd
8001224e:	d8 02       	popm	pc
    		theReturn = XNL_IDLE;// We're done here.
    	}else{ //A new instance has has been scheduled.

    		txSchedule.CurrentInstanceIndex = txSchedule.NextWaitingIndex; //Begin handling waiting instance.
80012250:	4d 18       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012252:	91 49       	st.w	r8[0x10],r9
    		txSchedule.NextWaitingIndex = TXINSTANCESBOUND;                //Allow BG to schedule new instance.
80012254:	30 4a       	mov	r10,4
80012256:	91 7a       	st.w	r8[0x1c],r10
    		txSchedule.CurrentBlockIndex = 0;                              //Handle to first fragment. Assume index to a valid fragment block.
80012258:	30 0a       	mov	r10,0
8001225a:	91 5a       	st.w	r8[0x14],r10
    		//txSchedule.Next16TxIndex = 0;                                //Points to first hWord in fragment block.
    		theReturn = TxBufferPool[TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[0]].XNL.theMAC_Header.phy_control;
8001225c:	a3 69       	lsl	r9,0x2
8001225e:	2f f9       	sub	r9,-1
80012260:	4c ea       	lddpc	r10,80012398 <XNL_PhyTx+0x174>
80012262:	f4 09 03 39 	ld.w	r9,r10[r9<<0x3]
80012266:	a9 69       	lsl	r9,0x8
80012268:	4c da       	lddpc	r10,8001239c <XNL_PhyTx+0x178>
8001226a:	f4 09 05 0c 	ld.uh	r12,r10[r9]
    		txSchedule.BytesRemaining = theReturn & 0x000000FF;
8001226e:	f3 dc c0 08 	bfextu	r9,r12,0x0,0x8
80012272:	91 39       	st.w	r8[0xc],r9
    		theReturn |= PHYHEADER32; //Transmit 0xABCD0000 | Type/Length.
80012274:	ea 1c ab cd 	orh	r12,0xabcd
    		txSchedule.Next16TxIndex = 1;
80012278:	30 19       	mov	r9,1
8001227a:	91 69       	st.w	r8[0x18],r9
    		txSchedule.TxLinkState = INSTANCETRANSMIT;
8001227c:	91 29       	st.w	r8[0x8],r9
8001227e:	d8 02       	popm	pc
    		//We're done here. The new transmission has started.
    	}
    	break;

    case INSTANCETRANSMIT:
    	theReturn = TxBufferPool[TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[txSchedule.CurrentBlockIndex]].u16[txSchedule.Next16TxIndex] << 16;
80012280:	4c 58       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012282:	70 6a       	ld.w	r10,r8[0x18]
80012284:	70 4b       	ld.w	r11,r8[0x10]
80012286:	70 59       	ld.w	r9,r8[0x14]
80012288:	f2 0b 00 3b 	add	r11,r9,r11<<0x3
8001228c:	2f eb       	sub	r11,-2
8001228e:	4c 39       	lddpc	r9,80012398 <XNL_PhyTx+0x174>
80012290:	f2 0b 03 2b 	ld.w	r11,r9[r11<<0x2]
80012294:	a7 7b       	lsl	r11,0x7
80012296:	14 0b       	add	r11,r10
80012298:	4c 19       	lddpc	r9,8001239c <XNL_PhyTx+0x178>
8001229a:	f2 0b 05 1c 	ld.uh	r12,r9[r11<<0x1]
8001229e:	b1 6c       	lsl	r12,0x10
    	txSchedule.Next16TxIndex += 1;
800122a0:	2f fa       	sub	r10,-1
800122a2:	91 6a       	st.w	r8[0x18],r10
    	txSchedule.BytesRemaining -= 2;
800122a4:	70 39       	ld.w	r9,r8[0xc]
800122a6:	20 29       	sub	r9,2
800122a8:	91 39       	st.w	r8[0xc],r9
    	if (txSchedule.BytesRemaining <= 0){ //Have written all the bytes (including 16-bit pad).
800122aa:	58 09       	cp.w	r9,0
800122ac:	e0 89 00 22 	brgt	800122f0 <XNL_PhyTx+0xcc>
    		//Must immediately send 0x00BA in Slot 4.
    		theReturn |= PHYTERMRIGHT;
800122b0:	e8 1c 00 ba 	orl	r12,0xba
    		txSchedule.CurrentBlockIndex += 1;  //Advance to next fragment in this instance.
800122b4:	70 59       	ld.w	r9,r8[0x14]
800122b6:	2f f9       	sub	r9,-1
800122b8:	91 59       	st.w	r8[0x14],r9
    		if (TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[txSchedule.CurrentBlockIndex] == TXBLOCKBOUND){ //All fragments of this instance have been transmitted.
800122ba:	70 48       	ld.w	r8,r8[0x10]
800122bc:	f2 08 00 39 	add	r9,r9,r8<<0x3
800122c0:	2f e9       	sub	r9,-2
800122c2:	4b 6a       	lddpc	r10,80012398 <XNL_PhyTx+0x174>
800122c4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800122c8:	59 09       	cp.w	r9,16
800122ca:	c0 f1       	brne	800122e8 <XNL_PhyTx+0xc4>
    			TxInstancePool[txSchedule.CurrentInstanceIndex].behavior &= 0x7FFFFFFF; //Release ownership.
    			TxInstancePool[txSchedule.CurrentInstanceIndex].behavior |= FGHASSENT;  //Flag sent.
800122cc:	a5 78       	lsl	r8,0x5
800122ce:	f4 08 00 08 	add	r8,r10,r8
800122d2:	70 09       	ld.w	r9,r8[0x0]
800122d4:	f3 d9 c0 1f 	bfextu	r9,r9,0x0,0x1f
800122d8:	bf a9       	sbr	r9,0x1e
800122da:	91 09       	st.w	r8[0x0],r9
    			txSchedule.CurrentInstanceIndex = TXINSTANCESBOUND; //Signal for anyone watching.
800122dc:	4a e8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
800122de:	30 49       	mov	r9,4
800122e0:	91 49       	st.w	r8[0x10],r9
    			txSchedule.TxLinkState = IDLEWAITINGSCHEDULE;       //Go back to waiting.
800122e2:	30 09       	mov	r9,0
800122e4:	91 29       	st.w	r8[0x8],r9
800122e6:	d8 02       	popm	pc
    			//Next interrupt will send Header for next fragment.
    			//txSchedule.CurrentInstanceIndex is unchanged.
    			//txSchedule.CurrentBlockIndex already points to next valid fragment block.
    			//txSchedule.BytesRemaining needs to be initialized.
    			//txSchedule.Next16TxIndex needs to be initialized.
    			txSchedule.TxLinkState = CONTINUINGNEWFRAGMENT;
800122e8:	30 29       	mov	r9,2
800122ea:	4a b8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
800122ec:	91 29       	st.w	r8[0x8],r9
800122ee:	d8 02       	popm	pc
    		}
    		break; //This fragment finished.
    	}

    	//Have not broken. Transmit 2nd hWord.
    	theReturn |= TxBufferPool[TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[txSchedule.CurrentBlockIndex]].u16[txSchedule.Next16TxIndex];
800122f0:	4a 98       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
800122f2:	70 4e       	ld.w	lr,r8[0x10]
800122f4:	70 5b       	ld.w	r11,r8[0x14]
800122f6:	f6 0e 00 3e 	add	lr,r11,lr<<0x3
800122fa:	2f ee       	sub	lr,-2
800122fc:	4a 7b       	lddpc	r11,80012398 <XNL_PhyTx+0x174>
800122fe:	f6 0e 03 2e 	ld.w	lr,r11[lr<<0x2]
80012302:	a7 7e       	lsl	lr,0x7
80012304:	14 0e       	add	lr,r10
80012306:	4a 6b       	lddpc	r11,8001239c <XNL_PhyTx+0x178>
80012308:	f6 0e 05 1b 	ld.uh	r11,r11[lr<<0x1]
8001230c:	16 4c       	or	r12,r11
    	txSchedule.Next16TxIndex += 1;
8001230e:	2f fa       	sub	r10,-1
80012310:	91 6a       	st.w	r8[0x18],r10
    	txSchedule.BytesRemaining -= 2;
80012312:	20 29       	sub	r9,2
80012314:	91 39       	st.w	r8[0xc],r9
    	if (txSchedule.BytesRemaining <= 0){ //Have written all the bytes (including 16-bit pad).
80012316:	58 09       	cp.w	r9,0
80012318:	e0 89 00 3d 	brgt	80012392 <XNL_PhyTx+0x16e>
    		//Must send 0x00BA0000 next interrupt in Slot 3&4.
    		//txSchedule.CurrentInstanceIndex is unchanged.
			//txSchedule.CurrentBlockIndex needs advancing and checking.
			//txSchedule.BytesRemaining needs to be initialized.
			//txSchedule.Next16TxIndex needs to be initialized.
    		txSchedule.TxLinkState = SENDINGTERMINATOR32;
8001231c:	30 39       	mov	r9,3
8001231e:	91 29       	st.w	r8[0x8],r9
80012320:	d8 02       	popm	pc
    	}
    	break;

    case SENDINGTERMINATOR32:
    	theReturn = PHYTERMLEFT;
    	txSchedule.CurrentBlockIndex += 1;  //Advance to next fragment in this instance.
80012322:	49 d8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012324:	70 59       	ld.w	r9,r8[0x14]
80012326:	2f f9       	sub	r9,-1
80012328:	91 59       	st.w	r8[0x14],r9
    	if (TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[txSchedule.CurrentBlockIndex] == TXBLOCKBOUND){ //All fragments of this instance have been transmitted.
8001232a:	70 48       	ld.w	r8,r8[0x10]
8001232c:	f2 08 00 39 	add	r9,r9,r8<<0x3
80012330:	2f e9       	sub	r9,-2
80012332:	49 aa       	lddpc	r10,80012398 <XNL_PhyTx+0x174>
80012334:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80012338:	59 09       	cp.w	r9,16
8001233a:	c1 11       	brne	8001235c <XNL_PhyTx+0x138>
    		TxInstancePool[txSchedule.CurrentInstanceIndex].behavior &= 0x7FFFFFFF; //Release ownership.
    		TxInstancePool[txSchedule.CurrentInstanceIndex].behavior |= FGHASSENT;  //Flag sent.
8001233c:	a5 78       	lsl	r8,0x5
8001233e:	f4 08 00 08 	add	r8,r10,r8
80012342:	70 09       	ld.w	r9,r8[0x0]
80012344:	f3 d9 c0 1f 	bfextu	r9,r9,0x0,0x1f
80012348:	bf a9       	sbr	r9,0x1e
8001234a:	91 09       	st.w	r8[0x0],r9
    	    txSchedule.CurrentInstanceIndex = TXINSTANCESBOUND; //Signal for anyone watching.
8001234c:	49 28       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
8001234e:	30 49       	mov	r9,4
80012350:	91 49       	st.w	r8[0x10],r9
    	    txSchedule.TxLinkState = IDLEWAITINGSCHEDULE;   //Go back to waiting.
80012352:	30 09       	mov	r9,0
80012354:	91 29       	st.w	r8[0x8],r9
80012356:	fc 1c 00 ba 	movh	r12,0xba
8001235a:	d8 02       	popm	pc
			//Next interrupt will send Header for next fragment.
			//txSchedule.CurrentInstanceIndex is unchanged.
			//txSchedule.CurrentBlockIndex already points to next valid fragment block.
			//txSchedule.BytesRemaining needs to be initialized.
			//txSchedule.Next16TxIndex needs to be initialized.
			txSchedule.TxLinkState = CONTINUINGNEWFRAGMENT;
8001235c:	30 29       	mov	r9,2
8001235e:	48 e8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
80012360:	91 29       	st.w	r8[0x8],r9
80012362:	fc 1c 00 ba 	movh	r12,0xba
80012366:	d8 02       	popm	pc
    	}
    	break; //This fragment finished.

    case CONTINUINGNEWFRAGMENT:
    	theReturn = TxBufferPool[TxInstancePool[txSchedule.CurrentInstanceIndex].BlockIndex[txSchedule.CurrentBlockIndex]].MAC.theMAC_Header.phy_control;
80012368:	48 b8       	lddpc	r8,80012394 <XNL_PhyTx+0x170>
8001236a:	70 4a       	ld.w	r10,r8[0x10]
8001236c:	70 59       	ld.w	r9,r8[0x14]
8001236e:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80012372:	2f ea       	sub	r10,-2
80012374:	48 99       	lddpc	r9,80012398 <XNL_PhyTx+0x174>
80012376:	f2 0a 03 29 	ld.w	r9,r9[r10<<0x2]
8001237a:	a9 69       	lsl	r9,0x8
8001237c:	48 8a       	lddpc	r10,8001239c <XNL_PhyTx+0x178>
8001237e:	f4 09 05 0c 	ld.uh	r12,r10[r9]
    	txSchedule.BytesRemaining = theReturn & 0x00FF;
80012382:	f3 dc c0 08 	bfextu	r9,r12,0x0,0x8
80012386:	91 39       	st.w	r8[0xc],r9
    	theReturn |= PHYHEADER32;     //Transmit 0xABCD0000  | Type/Length.
80012388:	ea 1c ab cd 	orh	r12,0xabcd
    	txSchedule.Next16TxIndex = 1;
8001238c:	30 19       	mov	r9,1
8001238e:	91 69       	st.w	r8[0x18],r9
    	txSchedule.TxLinkState = INSTANCETRANSMIT;
80012390:	91 29       	st.w	r8[0x8],r9
    	break; //We're done here. The continuing fragment has started.
    }//End of TxLinkState Switch
    return theReturn;
  }
80012392:	d8 02       	popm	pc
80012394:	00 00       	add	r0,r0
80012396:	49 24       	lddpc	r4,800123dc <RxPhyMedia+0x3c>
80012398:	00 00       	add	r0,r0
8001239a:	38 64       	mov	r4,-122
8001239c:	00 00       	add	r0,r0
8001239e:	39 04       	mov	r4,-112

800123a0 <RxPhyMedia>:


  void RxPhyMedia(void)
  {
	    //This is the RxMedia Phy Handler.
	    switch (theRxMediaCtrlr.RxMediaState){
800123a0:	fe f8 04 60 	ld.w	r8,pc[1120]
800123a4:	70 08       	ld.w	r8,r8[0x0]
800123a6:	58 18       	cp.w	r8,1
800123a8:	e0 80 01 50 	breq	80012648 <RxPhyMedia+0x2a8>
800123ac:	c0 43       	brcs	800123b4 <RxPhyMedia+0x14>
800123ae:	58 28       	cp.w	r8,2
800123b0:	5e 1c       	retne	r12
800123b2:	cb 48       	rjmp	8001251a <RxPhyMedia+0x17a>
	    case WAITINGABAB:
	    	if ( RxBuffer[BufferIndex].thePayload_Channel.word[0] == 0xABCD5A5A) break;                  //Ignore Idles.
800123b4:	fe f8 04 50 	ld.w	r8,pc[1104]
800123b8:	11 89       	ld.ub	r9,r8[0x0]
800123ba:	a1 79       	lsl	r9,0x1
800123bc:	2f f9       	sub	r9,-1
800123be:	fe f8 04 4a 	ld.w	r8,pc[1098]
800123c2:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
800123c6:	e0 69 5a 5a 	mov	r9,23130
800123ca:	ea 19 ab cd 	orh	r9,0xabcd
800123ce:	12 38       	cp.w	r8,r9
800123d0:	5e 0c       	reteq	r12
	    	if ((RxBuffer[BufferIndex].thePayload_Channel.word[0]  & 0xFFFF0000) != 0xABCD0000) break;   //Skip until Header.
800123d2:	fe f8 04 32 	ld.w	r8,pc[1074]
800123d6:	11 89       	ld.ub	r9,r8[0x0]
800123d8:	a1 79       	lsl	r9,0x1
800123da:	2f f9       	sub	r9,-1
800123dc:	fe f8 04 2c 	ld.w	r8,pc[1068]
800123e0:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
800123e4:	e0 18 00 00 	andl	r8,0x0
800123e8:	fc 19 ab cd 	movh	r9,0xabcd
800123ec:	12 38       	cp.w	r8,r9
800123ee:	5e 1c       	retne	r12
	    	if ((RxBuffer[BufferIndex].thePayload_Channel.word[0]  & 0x0000F000) != 0x00005000) break;   //Skip on non-PAYLOAD_DATA_RX.
800123f0:	fe f8 04 14 	ld.w	r8,pc[1044]
800123f4:	11 89       	ld.ub	r9,r8[0x0]
800123f6:	a1 79       	lsl	r9,0x1
800123f8:	2f f9       	sub	r9,-1
800123fa:	fe f8 04 0e 	ld.w	r8,pc[1038]
800123fe:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
80012402:	e2 18 f0 00 	andl	r8,0xf000,COH
80012406:	e0 48 50 00 	cp.w	r8,20480
8001240a:	5e 1c       	retne	r12
	    	theRxMediaCtrlr.RxBytesWaiting = RxBuffer[BufferIndex].thePayload_Channel.word[0] & 0x000000FF;
8001240c:	fe f9 03 f8 	ld.w	r9,pc[1016]
80012410:	13 8a       	ld.ub	r10,r9[0x0]
80012412:	fe f8 03 f6 	ld.w	r8,pc[1014]
80012416:	a1 7a       	lsl	r10,0x1
80012418:	2f fa       	sub	r10,-1
8001241a:	f0 0a 03 3a 	ld.w	r10,r8[r10<<0x3]
8001241e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80012422:	fe fb 03 de 	ld.w	r11,pc[990]
80012426:	97 2a       	st.w	r11[0x8],r10
	    	if ((RxBuffer[BufferIndex].thePayload_Channel.word[0]  & 0x00000F00) <= 1){  //Frag type must process Array Discriptor.
80012428:	13 89       	ld.ub	r9,r9[0x0]
8001242a:	a1 79       	lsl	r9,0x1
8001242c:	2f f9       	sub	r9,-1
8001242e:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
80012432:	e2 18 0f 00 	andl	r8,0xf00,COH
80012436:	58 18       	cp.w	r8,1
80012438:	e0 8b 00 48 	brhi	800124c8 <RxPhyMedia+0x128>
	    		//The first word of the media access payload must be the Array descriptor length. And the
	    	    //unit of the length is in word (16-bit). The length field itself does not count into the length.
	    	    //When there is no array descriptor, the length must be set to zero.[9.1.4.1]
	    		if ((theRxMediaCtrlr.RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8001243c:	20 4a       	sub	r10,4
8001243e:	97 2a       	st.w	r11[0x8],r10
80012440:	58 0a       	cp.w	r10,0
80012442:	5e ac       	retle	r12
	    		theRxMediaCtrlr.ArrayDiscLength = RxBuffer[BufferIndex].thePayload_Channel.hword[2];
80012444:	fe f8 03 c0 	ld.w	r8,pc[960]
80012448:	11 88       	ld.ub	r8,r8[0x0]
8001244a:	a5 68       	lsl	r8,0x4
8001244c:	fe f9 03 bc 	ld.w	r9,pc[956]
80012450:	f2 08 00 08 	add	r8,r9,r8
80012454:	2f 48       	sub	r8,-12
80012456:	90 08       	ld.sh	r8,r8[0x0]
80012458:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8001245c:	97 39       	st.w	r11[0xc],r9
	    		switch (theRxMediaCtrlr.ArrayDiscLength){
8001245e:	30 0a       	mov	r10,0
80012460:	f4 08 19 00 	cp.h	r8,r10
80012464:	c0 60       	breq	80012470 <RxPhyMedia+0xd0>
80012466:	30 1a       	mov	r10,1
80012468:	f4 08 19 00 	cp.h	r8,r10
8001246c:	c2 71       	brne	800124ba <RxPhyMedia+0x11a>
8001246e:	c2 18       	rjmp	800124b0 <RxPhyMedia+0x110>
	    		case 0:          //The usual case. Remaining word in Phy buffer is Audio.
	    			RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[3];
80012470:	fe f9 03 90 	ld.w	r9,pc[912]
80012474:	72 18       	ld.w	r8,r9[0x4]
80012476:	fe fa 03 8e 	ld.w	r10,pc[910]
8001247a:	15 8a       	ld.ub	r10,r10[0x0]
8001247c:	a5 6a       	lsl	r10,0x4
8001247e:	fe fb 03 8a 	ld.w	r11,pc[906]
80012482:	f6 0a 00 0a 	add	r10,r11,r10
80012486:	2f 2a       	sub	r10,-14
80012488:	94 0b       	ld.sh	r11,r10[0x0]
8001248a:	fe fa 03 82 	ld.w	r10,pc[898]
8001248e:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    			theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
80012492:	2f f8       	sub	r8,-1
80012494:	93 18       	st.w	r9[0x4],r8
	    			if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
80012496:	e0 48 13 ff 	cp.w	r8,5119
8001249a:	e0 8a 00 06 	brle	800124a6 <RxPhyMedia+0x106>
8001249e:	30 09       	mov	r9,0
800124a0:	fe f8 03 60 	ld.w	r8,pc[864]
800124a4:	91 19       	st.w	r8[0x4],r9
	    			theRxMediaCtrlr.RxMediaState = READINGMEDIA;
800124a6:	30 29       	mov	r9,2
800124a8:	fe f8 03 58 	ld.w	r8,pc[856]
800124ac:	91 09       	st.w	r8[0x0],r9
	    			break;
800124ae:	5e fc       	retal	r12
	    		case 1:          //The next usual case.
	    			//In general case, add code to process single word Array discriptor.
	    			theRxMediaCtrlr.RxMediaState = READINGMEDIA;
800124b0:	30 29       	mov	r9,2
800124b2:	fe f8 03 4e 	ld.w	r8,pc[846]
800124b6:	91 09       	st.w	r8[0x0],r9
	    			break;
800124b8:	5e fc       	retal	r12
	    		default:         //So far, can't happen, but need to code anyway.
	    			//In general, add code to process multiword array discriptor.
	    		    theRxMediaCtrlr.ArrayDiscLength -= 1;
800124ba:	fe f8 03 46 	ld.w	r8,pc[838]
800124be:	20 19       	sub	r9,1
800124c0:	91 39       	st.w	r8[0xc],r9
	    		    theRxMediaCtrlr.RxMediaState = READINGARRAYDISCRPT;
800124c2:	30 19       	mov	r9,1
800124c4:	91 09       	st.w	r8[0x0],r9
800124c6:	5e fc       	retal	r12
	    		}
	    		break;
	    	}
	    	//Code gets here on middle or last fragment. No Array descriptor.
	    	if (theRxMediaCtrlr.RxBytesWaiting < 2) break;          //This shouldn't happen, but must check.
800124c8:	58 1a       	cp.w	r10,1
800124ca:	5e ac       	retle	r12
	    	RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.word[1] & 0x0000FFFF;
800124cc:	fe f9 03 34 	ld.w	r9,pc[820]
800124d0:	72 18       	ld.w	r8,r9[0x4]
800124d2:	fe fa 03 32 	ld.w	r10,pc[818]
800124d6:	15 8a       	ld.ub	r10,r10[0x0]
800124d8:	a5 6a       	lsl	r10,0x4
800124da:	fe fb 03 2e 	ld.w	r11,pc[814]
800124de:	f6 0a 00 0a 	add	r10,r11,r10
800124e2:	2f 4a       	sub	r10,-12
800124e4:	74 0b       	ld.w	r11,r10[0x0]
800124e6:	fe fa 03 26 	ld.w	r10,pc[806]
800124ea:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    	theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
800124ee:	2f f8       	sub	r8,-1
800124f0:	93 18       	st.w	r9[0x4],r8
	    	if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
800124f2:	e0 48 13 ff 	cp.w	r8,5119
800124f6:	e0 8a 00 06 	brle	80012502 <RxPhyMedia+0x162>
800124fa:	30 09       	mov	r9,0
800124fc:	fe f8 03 04 	ld.w	r8,pc[772]
80012500:	91 19       	st.w	r8[0x4],r9
	    	if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80012502:	fe f9 02 fe 	ld.w	r9,pc[766]
80012506:	72 28       	ld.w	r8,r9[0x8]
80012508:	20 28       	sub	r8,2
8001250a:	93 28       	st.w	r9[0x8],r8
8001250c:	58 08       	cp.w	r8,0
8001250e:	5e ac       	retle	r12
	    	theRxMediaCtrlr.RxMediaState = READINGMEDIA;
80012510:	30 29       	mov	r9,2
80012512:	fe f8 02 ee 	ld.w	r8,pc[750]
80012516:	91 09       	st.w	r8[0x0],r9
	    	break; //End of WAITINGABAB.
80012518:	5e fc       	retal	r12

	    case READINGMEDIA:
	    	RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[0];
8001251a:	fe f9 02 e6 	ld.w	r9,pc[742]
8001251e:	72 18       	ld.w	r8,r9[0x4]
80012520:	fe fa 02 e4 	ld.w	r10,pc[740]
80012524:	15 8b       	ld.ub	r11,r10[0x0]
80012526:	a1 7b       	lsl	r11,0x1
80012528:	2f fb       	sub	r11,-1
8001252a:	fe fa 02 de 	ld.w	r10,pc[734]
8001252e:	f4 0b 04 3b 	ld.sh	r11,r10[r11<<0x3]
80012532:	fe fa 02 da 	ld.w	r10,pc[730]
80012536:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    	theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
8001253a:	2f f8       	sub	r8,-1
8001253c:	93 18       	st.w	r9[0x4],r8
	    	if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
8001253e:	e0 48 13 ff 	cp.w	r8,5119
80012542:	e0 8a 00 06 	brle	8001254e <RxPhyMedia+0x1ae>
80012546:	30 09       	mov	r9,0
80012548:	fe f8 02 b8 	ld.w	r8,pc[696]
8001254c:	91 19       	st.w	r8[0x4],r9
	    	if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0){
8001254e:	fe f9 02 b2 	ld.w	r9,pc[690]
80012552:	72 28       	ld.w	r8,r9[0x8]
80012554:	20 28       	sub	r8,2
80012556:	93 28       	st.w	r9[0x8],r8
80012558:	58 08       	cp.w	r8,0
8001255a:	e0 89 00 07 	brgt	80012568 <RxPhyMedia+0x1c8>
	    		theRxMediaCtrlr.RxMediaState = WAITINGABAB;
8001255e:	30 09       	mov	r9,0
80012560:	fe f8 02 a0 	ld.w	r8,pc[672]
80012564:	91 09       	st.w	r8[0x0],r9
	    		break;
80012566:	5e fc       	retal	r12
	    	}

	    	RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[1];
80012568:	fe f9 02 98 	ld.w	r9,pc[664]
8001256c:	72 18       	ld.w	r8,r9[0x4]
8001256e:	fe fa 02 96 	ld.w	r10,pc[662]
80012572:	15 8a       	ld.ub	r10,r10[0x0]
80012574:	a5 6a       	lsl	r10,0x4
80012576:	fe fb 02 92 	ld.w	r11,pc[658]
8001257a:	f6 0a 00 0a 	add	r10,r11,r10
8001257e:	2f 6a       	sub	r10,-10
80012580:	94 0b       	ld.sh	r11,r10[0x0]
80012582:	fe fa 02 8a 	ld.w	r10,pc[650]
80012586:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    	theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
8001258a:	2f f8       	sub	r8,-1
8001258c:	93 18       	st.w	r9[0x4],r8
	    	if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
8001258e:	e0 48 13 ff 	cp.w	r8,5119
80012592:	e0 8a 00 06 	brle	8001259e <RxPhyMedia+0x1fe>
80012596:	30 09       	mov	r9,0
80012598:	fe f8 02 68 	ld.w	r8,pc[616]
8001259c:	91 19       	st.w	r8[0x4],r9
	    	if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0){
8001259e:	fe f9 02 62 	ld.w	r9,pc[610]
800125a2:	72 28       	ld.w	r8,r9[0x8]
800125a4:	20 28       	sub	r8,2
800125a6:	93 28       	st.w	r9[0x8],r8
800125a8:	58 08       	cp.w	r8,0
800125aa:	e0 89 00 07 	brgt	800125b8 <RxPhyMedia+0x218>
	    	   theRxMediaCtrlr.RxMediaState = WAITINGABAB;
800125ae:	30 09       	mov	r9,0
800125b0:	fe f8 02 50 	ld.w	r8,pc[592]
800125b4:	91 09       	st.w	r8[0x0],r9
	    	   break;
800125b6:	5e fc       	retal	r12
	    	}

	    	RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[2];
800125b8:	fe f9 02 48 	ld.w	r9,pc[584]
800125bc:	72 18       	ld.w	r8,r9[0x4]
800125be:	fe fa 02 46 	ld.w	r10,pc[582]
800125c2:	15 8a       	ld.ub	r10,r10[0x0]
800125c4:	a5 6a       	lsl	r10,0x4
800125c6:	fe fb 02 42 	ld.w	r11,pc[578]
800125ca:	f6 0a 00 0a 	add	r10,r11,r10
800125ce:	2f 4a       	sub	r10,-12
800125d0:	94 0b       	ld.sh	r11,r10[0x0]
800125d2:	fe fa 02 3a 	ld.w	r10,pc[570]
800125d6:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    	theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
800125da:	2f f8       	sub	r8,-1
800125dc:	93 18       	st.w	r9[0x4],r8
	    	if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
800125de:	e0 48 13 ff 	cp.w	r8,5119
800125e2:	e0 8a 00 06 	brle	800125ee <RxPhyMedia+0x24e>
800125e6:	30 09       	mov	r9,0
800125e8:	fe f8 02 18 	ld.w	r8,pc[536]
800125ec:	91 19       	st.w	r8[0x4],r9
	    	if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0){
800125ee:	fe f9 02 12 	ld.w	r9,pc[530]
800125f2:	72 28       	ld.w	r8,r9[0x8]
800125f4:	20 28       	sub	r8,2
800125f6:	93 28       	st.w	r9[0x8],r8
800125f8:	58 08       	cp.w	r8,0
800125fa:	e0 89 00 07 	brgt	80012608 <RxPhyMedia+0x268>
	    	    theRxMediaCtrlr.RxMediaState = WAITINGABAB;
800125fe:	30 09       	mov	r9,0
80012600:	fe f8 02 00 	ld.w	r8,pc[512]
80012604:	91 09       	st.w	r8[0x0],r9
	    	    break;
80012606:	5e fc       	retal	r12
	    	}

	    	RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[3];
80012608:	4f e9       	lddpc	r9,80012800 <RxPhyMedia+0x460>
8001260a:	72 18       	ld.w	r8,r9[0x4]
8001260c:	4f ea       	lddpc	r10,80012804 <RxPhyMedia+0x464>
8001260e:	15 8a       	ld.ub	r10,r10[0x0]
80012610:	a5 6a       	lsl	r10,0x4
80012612:	4f eb       	lddpc	r11,80012808 <RxPhyMedia+0x468>
80012614:	f6 0a 00 0a 	add	r10,r11,r10
80012618:	2f 2a       	sub	r10,-14
8001261a:	94 0b       	ld.sh	r11,r10[0x0]
8001261c:	4f ca       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
8001261e:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
	    	theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
80012622:	2f f8       	sub	r8,-1
80012624:	93 18       	st.w	r9[0x4],r8
	    	if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
80012626:	e0 48 13 ff 	cp.w	r8,5119
8001262a:	e0 8a 00 05 	brle	80012634 <RxPhyMedia+0x294>
8001262e:	30 09       	mov	r9,0
80012630:	4f 48       	lddpc	r8,80012800 <RxPhyMedia+0x460>
80012632:	91 19       	st.w	r8[0x4],r9
	    	if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0){
80012634:	4f 39       	lddpc	r9,80012800 <RxPhyMedia+0x460>
80012636:	72 28       	ld.w	r8,r9[0x8]
80012638:	20 28       	sub	r8,2
8001263a:	93 28       	st.w	r9[0x8],r8
8001263c:	58 08       	cp.w	r8,0
8001263e:	5e 9c       	retgt	r12
	    	    theRxMediaCtrlr.RxMediaState = WAITINGABAB;
80012640:	30 09       	mov	r9,0
80012642:	4f 08       	lddpc	r8,80012800 <RxPhyMedia+0x460>
80012644:	91 09       	st.w	r8[0x0],r9
	    	    break;
80012646:	5e fc       	retal	r12
	    	break; //End of READINGMEDIA.


		case READINGARRAYDISCRPT:  //So far, this cannot happen, but needed for forward compatibility.
			//Array descriptorLength is greater than 0 on entry here.
			if(theRxMediaCtrlr.ArrayDiscLength > 4){ //All 4 words are still array discriptor.
80012648:	4e e8       	lddpc	r8,80012800 <RxPhyMedia+0x460>
8001264a:	70 38       	ld.w	r8,r8[0xc]
8001264c:	58 48       	cp.w	r8,4
8001264e:	e0 8a 00 0e 	brle	8001266a <RxPhyMedia+0x2ca>
				//For now, continue discarding.
				theRxMediaCtrlr.ArrayDiscLength -= 4;
80012652:	4e c9       	lddpc	r9,80012800 <RxPhyMedia+0x460>
80012654:	20 48       	sub	r8,4
80012656:	93 38       	st.w	r9[0xc],r8
				theRxMediaCtrlr.RxBytesWaiting  -= 8;
80012658:	72 28       	ld.w	r8,r9[0x8]
8001265a:	20 88       	sub	r8,8
8001265c:	93 28       	st.w	r9[0x8],r8
				if (theRxMediaCtrlr.RxBytesWaiting <= 0)theRxMediaCtrlr.RxMediaState = WAITINGABAB;
8001265e:	58 08       	cp.w	r8,0
80012660:	5e 9c       	retgt	r12
80012662:	30 09       	mov	r9,0
80012664:	4e 78       	lddpc	r8,80012800 <RxPhyMedia+0x460>
80012666:	91 09       	st.w	r8[0x0],r9
80012668:	5e fc       	retal	r12
				break;
			}

			switch (theRxMediaCtrlr.ArrayDiscLength){ //1,2, or 3
8001266a:	58 28       	cp.w	r8,2
8001266c:	c2 80       	breq	800126bc <RxPhyMedia+0x31c>
8001266e:	58 38       	cp.w	r8,3
80012670:	c0 50       	breq	8001267a <RxPhyMedia+0x2da>
80012672:	58 18       	cp.w	r8,1
80012674:	e0 81 00 b9 	brne	800127e6 <RxPhyMedia+0x446>
80012678:	c5 f8       	rjmp	80012736 <RxPhyMedia+0x396>
			case 3:
				if ((theRxMediaCtrlr.RxBytesWaiting -= 6) <= 0) break;  //Throw away 3 hWords.
8001267a:	4e 29       	lddpc	r9,80012800 <RxPhyMedia+0x460>
8001267c:	72 28       	ld.w	r8,r9[0x8]
8001267e:	20 68       	sub	r8,6
80012680:	93 28       	st.w	r9[0x8],r8
80012682:	58 08       	cp.w	r8,0
80012684:	e0 8a 00 b6 	brle	800127f0 <RxPhyMedia+0x450>
				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[3];
80012688:	72 18       	ld.w	r8,r9[0x4]
8001268a:	4d fa       	lddpc	r10,80012804 <RxPhyMedia+0x464>
8001268c:	15 8a       	ld.ub	r10,r10[0x0]
8001268e:	a5 6a       	lsl	r10,0x4
80012690:	4d eb       	lddpc	r11,80012808 <RxPhyMedia+0x468>
80012692:	f6 0a 00 0a 	add	r10,r11,r10
80012696:	2f 2a       	sub	r10,-14
80012698:	94 0b       	ld.sh	r11,r10[0x0]
8001269a:	4d da       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
8001269c:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
800126a0:	2f f8       	sub	r8,-1
800126a2:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
800126a4:	e0 48 13 ff 	cp.w	r8,5119
800126a8:	e0 8a 00 05 	brle	800126b2 <RxPhyMedia+0x312>
800126ac:	30 09       	mov	r9,0
800126ae:	4d 58       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800126b0:	91 19       	st.w	r8[0x4],r9
				theRxMediaCtrlr.RxBytesWaiting -= 2;
800126b2:	4d 48       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800126b4:	70 29       	ld.w	r9,r8[0x8]
800126b6:	20 29       	sub	r9,2
800126b8:	91 29       	st.w	r8[0x8],r9
				break;
800126ba:	c9 68       	rjmp	800127e6 <RxPhyMedia+0x446>
			case 2:
				if ((theRxMediaCtrlr.RxBytesWaiting -= 4) <= 0) break;  //Throw away 2 hWords.
800126bc:	4d 19       	lddpc	r9,80012800 <RxPhyMedia+0x460>
800126be:	72 28       	ld.w	r8,r9[0x8]
800126c0:	20 48       	sub	r8,4
800126c2:	93 28       	st.w	r9[0x8],r8
800126c4:	58 08       	cp.w	r8,0
800126c6:	e0 8a 00 95 	brle	800127f0 <RxPhyMedia+0x450>
				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[2];
800126ca:	72 18       	ld.w	r8,r9[0x4]
800126cc:	4c ea       	lddpc	r10,80012804 <RxPhyMedia+0x464>
800126ce:	15 8a       	ld.ub	r10,r10[0x0]
800126d0:	a5 6a       	lsl	r10,0x4
800126d2:	4c eb       	lddpc	r11,80012808 <RxPhyMedia+0x468>
800126d4:	f6 0a 00 0a 	add	r10,r11,r10
800126d8:	2f 4a       	sub	r10,-12
800126da:	94 0b       	ld.sh	r11,r10[0x0]
800126dc:	4c ca       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
800126de:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
800126e2:	2f f8       	sub	r8,-1
800126e4:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
800126e6:	e0 48 13 ff 	cp.w	r8,5119
800126ea:	e0 8a 00 05 	brle	800126f4 <RxPhyMedia+0x354>
800126ee:	30 09       	mov	r9,0
800126f0:	4c 48       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800126f2:	91 19       	st.w	r8[0x4],r9
				if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0)break;
800126f4:	4c 39       	lddpc	r9,80012800 <RxPhyMedia+0x460>
800126f6:	72 28       	ld.w	r8,r9[0x8]
800126f8:	20 28       	sub	r8,2
800126fa:	93 28       	st.w	r9[0x8],r8
800126fc:	58 08       	cp.w	r8,0
800126fe:	e0 8a 00 79 	brle	800127f0 <RxPhyMedia+0x450>

				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[3];
80012702:	72 18       	ld.w	r8,r9[0x4]
80012704:	4c 0a       	lddpc	r10,80012804 <RxPhyMedia+0x464>
80012706:	15 8a       	ld.ub	r10,r10[0x0]
80012708:	a5 6a       	lsl	r10,0x4
8001270a:	4c 0b       	lddpc	r11,80012808 <RxPhyMedia+0x468>
8001270c:	f6 0a 00 0a 	add	r10,r11,r10
80012710:	2f 2a       	sub	r10,-14
80012712:	94 0b       	ld.sh	r11,r10[0x0]
80012714:	4b ea       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
80012716:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
8001271a:	2f f8       	sub	r8,-1
8001271c:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
8001271e:	e0 48 13 ff 	cp.w	r8,5119
80012722:	e0 8a 00 05 	brle	8001272c <RxPhyMedia+0x38c>
80012726:	30 09       	mov	r9,0
80012728:	4b 68       	lddpc	r8,80012800 <RxPhyMedia+0x460>
8001272a:	91 19       	st.w	r8[0x4],r9
				theRxMediaCtrlr.RxBytesWaiting -= 2;
8001272c:	4b 58       	lddpc	r8,80012800 <RxPhyMedia+0x460>
8001272e:	70 29       	ld.w	r9,r8[0x8]
80012730:	20 29       	sub	r9,2
80012732:	91 29       	st.w	r8[0x8],r9
			    break;;
80012734:	c5 98       	rjmp	800127e6 <RxPhyMedia+0x446>
			case 1:
				if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0) break;  //Throw away 1 hWords.
80012736:	4b 39       	lddpc	r9,80012800 <RxPhyMedia+0x460>
80012738:	72 28       	ld.w	r8,r9[0x8]
8001273a:	20 28       	sub	r8,2
8001273c:	93 28       	st.w	r9[0x8],r8
8001273e:	58 08       	cp.w	r8,0
80012740:	e0 8a 00 58 	brle	800127f0 <RxPhyMedia+0x450>
				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[1];
80012744:	72 18       	ld.w	r8,r9[0x4]
80012746:	4b 0a       	lddpc	r10,80012804 <RxPhyMedia+0x464>
80012748:	15 8a       	ld.ub	r10,r10[0x0]
8001274a:	a5 6a       	lsl	r10,0x4
8001274c:	4a fb       	lddpc	r11,80012808 <RxPhyMedia+0x468>
8001274e:	f6 0a 00 0a 	add	r10,r11,r10
80012752:	2f 6a       	sub	r10,-10
80012754:	94 0b       	ld.sh	r11,r10[0x0]
80012756:	4a ea       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
80012758:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
8001275c:	2f f8       	sub	r8,-1
8001275e:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
80012760:	e0 48 13 ff 	cp.w	r8,5119
80012764:	e0 8a 00 05 	brle	8001276e <RxPhyMedia+0x3ce>
80012768:	30 09       	mov	r9,0
8001276a:	4a 68       	lddpc	r8,80012800 <RxPhyMedia+0x460>
8001276c:	91 19       	st.w	r8[0x4],r9
				if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0)break;
8001276e:	4a 59       	lddpc	r9,80012800 <RxPhyMedia+0x460>
80012770:	72 28       	ld.w	r8,r9[0x8]
80012772:	20 28       	sub	r8,2
80012774:	93 28       	st.w	r9[0x8],r8
80012776:	58 08       	cp.w	r8,0
80012778:	e0 8a 00 3c 	brle	800127f0 <RxPhyMedia+0x450>

				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[2];
8001277c:	72 18       	ld.w	r8,r9[0x4]
8001277e:	4a 2a       	lddpc	r10,80012804 <RxPhyMedia+0x464>
80012780:	15 8a       	ld.ub	r10,r10[0x0]
80012782:	a5 6a       	lsl	r10,0x4
80012784:	4a 1b       	lddpc	r11,80012808 <RxPhyMedia+0x468>
80012786:	f6 0a 00 0a 	add	r10,r11,r10
8001278a:	2f 4a       	sub	r10,-12
8001278c:	94 0b       	ld.sh	r11,r10[0x0]
8001278e:	4a 0a       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
80012790:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
80012794:	2f f8       	sub	r8,-1
80012796:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
80012798:	e0 48 13 ff 	cp.w	r8,5119
8001279c:	e0 8a 00 05 	brle	800127a6 <RxPhyMedia+0x406>
800127a0:	30 09       	mov	r9,0
800127a2:	49 88       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127a4:	91 19       	st.w	r8[0x4],r9
				if ((theRxMediaCtrlr.RxBytesWaiting -= 2) <= 0)break;
800127a6:	49 79       	lddpc	r9,80012800 <RxPhyMedia+0x460>
800127a8:	72 28       	ld.w	r8,r9[0x8]
800127aa:	20 28       	sub	r8,2
800127ac:	93 28       	st.w	r9[0x8],r8
800127ae:	58 08       	cp.w	r8,0
800127b0:	e0 8a 00 20 	brle	800127f0 <RxPhyMedia+0x450>

				RxMediaBuffer[theRxMediaCtrlr.RxMedia_IsFillingNext16] = RxBuffer[BufferIndex].thePayload_Channel.hword[3];
800127b4:	72 18       	ld.w	r8,r9[0x4]
800127b6:	49 4a       	lddpc	r10,80012804 <RxPhyMedia+0x464>
800127b8:	15 8a       	ld.ub	r10,r10[0x0]
800127ba:	a5 6a       	lsl	r10,0x4
800127bc:	49 3b       	lddpc	r11,80012808 <RxPhyMedia+0x468>
800127be:	f6 0a 00 0a 	add	r10,r11,r10
800127c2:	2f 2a       	sub	r10,-14
800127c4:	94 0b       	ld.sh	r11,r10[0x0]
800127c6:	49 2a       	lddpc	r10,8001280c <RxPhyMedia+0x46c>
800127c8:	f4 08 0a 1b 	st.h	r10[r8<<0x1],r11
				theRxMediaCtrlr.RxMedia_IsFillingNext16 += 1;
800127cc:	2f f8       	sub	r8,-1
800127ce:	93 18       	st.w	r9[0x4],r8
				if (theRxMediaCtrlr.RxMedia_IsFillingNext16 >= RXMEDIABUFFERSIZE)theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
800127d0:	e0 48 13 ff 	cp.w	r8,5119
800127d4:	e0 8a 00 05 	brle	800127de <RxPhyMedia+0x43e>
800127d8:	30 09       	mov	r9,0
800127da:	48 a8       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127dc:	91 19       	st.w	r8[0x4],r9
				theRxMediaCtrlr.RxBytesWaiting -= 2;
800127de:	48 98       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127e0:	70 29       	ld.w	r9,r8[0x8]
800127e2:	20 29       	sub	r9,2
800127e4:	91 29       	st.w	r8[0x8],r9
				break;
			}
			if (theRxMediaCtrlr.RxBytesWaiting <= 0){
800127e6:	48 78       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127e8:	70 28       	ld.w	r8,r8[0x8]
800127ea:	58 08       	cp.w	r8,0
800127ec:	e0 89 00 06 	brgt	800127f8 <RxPhyMedia+0x458>
				theRxMediaCtrlr.RxMediaState = WAITINGABAB;
800127f0:	30 09       	mov	r9,0
800127f2:	48 48       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127f4:	91 09       	st.w	r8[0x0],r9
800127f6:	5e fc       	retal	r12
			}else{
				theRxMediaCtrlr.RxMediaState = READINGMEDIA;
800127f8:	30 29       	mov	r9,2
800127fa:	48 28       	lddpc	r8,80012800 <RxPhyMedia+0x460>
800127fc:	91 09       	st.w	r8[0x0],r9
800127fe:	5e fc       	retal	r12
80012800:	00 00       	add	r0,r0
80012802:	00 0c       	add	r12,r0
80012804:	00 00       	add	r0,r0
80012806:	00 1c       	sub	r12,r0
80012808:	00 00       	add	r0,r0
8001280a:	38 e4       	mov	r4,-114
8001280c:	00 00       	add	r0,r0
8001280e:	00 1e       	sub	lr,r0

80012810 <_unhandled_interrupt>:
  }

  //brief Default interrupt handler.
  __attribute__((__interrupt__))
  static void _unhandled_interrupt(void)
  {
80012810:	c0 08       	rjmp	80012810 <_unhandled_interrupt>

80012812 <_external_interrupt>:
  //External (accelerometer) interrupt handler.
  __attribute__((__interrupt__))
  static void _external_interrupt(void)
  {
        //Reserved for Double-Tap Interrupt.
  }
80012812:	d6 03       	rete

80012814 <reserveTxInstance>:
//If successful, it will return an Index
//to the Instance (<TXINSTANCESBOUND). If unsuccessful,
//it will return == TXINSTANCESBOUND. The requesting routine
//must check this!
U8 reserveTxInstance(int BlocksNeeded)
{
80012814:	d4 31       	pushm	r0-r7,lr
	//This is really un-necessary, and wastes two bytes of RAM. If the
	//values stored in AvailableInstanceCount or AvailableBlockCount
	//ever drift, there will be a problem. This *may* be useful for
	//automating performance metrics. [I *think* you can remove this test
	//and still work.]
	if ((txSchedule.AvailableInstanceCount < 1)
80012816:	4b 48       	lddpc	r8,800128e4 <reserveTxInstance+0xd0>
80012818:	70 09       	ld.w	r9,r8[0x0]
8001281a:	58 09       	cp.w	r9,0
8001281c:	5f aa       	srle	r10
8001281e:	70 18       	ld.w	r8,r8[0x4]
80012820:	18 38       	cp.w	r8,r12
80012822:	5f 58       	srlt	r8
80012824:	f5 e8 10 08 	or	r8,r10,r8
80012828:	c0 30       	breq	8001282e <reserveTxInstance+0x1a>
8001282a:	30 45       	mov	r5,4
8001282c:	c5 98       	rjmp	800128de <reserveTxInstance+0xca>
		| (txSchedule.AvailableBlockCount < BlocksNeeded))
		return TXINSTANCESBOUND;


	for (instanceIndex=0; instanceIndex<TXINSTANCESIMPLEMENTED; instanceIndex++){
		if (TxInstancePool[instanceIndex].behavior == NULLINSTANCEBEHAVIOR){
8001282e:	4a f8       	lddpc	r8,800128e8 <reserveTxInstance+0xd4>
80012830:	70 08       	ld.w	r8,r8[0x0]
80012832:	58 08       	cp.w	r8,0
80012834:	c0 31       	brne	8001283a <reserveTxInstance+0x26>
80012836:	10 95       	mov	r5,r8
80012838:	c1 58       	rjmp	80012862 <reserveTxInstance+0x4e>
8001283a:	4a c8       	lddpc	r8,800128e8 <reserveTxInstance+0xd4>
8001283c:	70 88       	ld.w	r8,r8[0x20]
8001283e:	58 08       	cp.w	r8,0
80012840:	c0 41       	brne	80012848 <reserveTxInstance+0x34>
80012842:	30 18       	mov	r8,1
80012844:	10 95       	mov	r5,r8
80012846:	c0 e8       	rjmp	80012862 <reserveTxInstance+0x4e>
80012848:	4a 88       	lddpc	r8,800128e8 <reserveTxInstance+0xd4>
8001284a:	71 08       	ld.w	r8,r8[0x40]
8001284c:	58 08       	cp.w	r8,0
8001284e:	c0 41       	brne	80012856 <reserveTxInstance+0x42>
80012850:	30 28       	mov	r8,2
80012852:	10 95       	mov	r5,r8
80012854:	c0 78       	rjmp	80012862 <reserveTxInstance+0x4e>
80012856:	4a 58       	lddpc	r8,800128e8 <reserveTxInstance+0xd4>
80012858:	71 88       	ld.w	r8,r8[0x60]
8001285a:	58 08       	cp.w	r8,0
8001285c:	c3 d1       	brne	800128d6 <reserveTxInstance+0xc2>
8001285e:	30 38       	mov	r8,3
80012860:	10 95       	mov	r5,r8
			//Code gets here when the available instance is found.
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
80012862:	4a 2a       	lddpc	r10,800128e8 <reserveTxInstance+0xd4>
80012864:	f0 0b 15 03 	lsl	r11,r8,0x3
80012868:	2f fb       	sub	r11,-1
8001286a:	4a 1e       	lddpc	lr,800128ec <reserveTxInstance+0xd8>
8001286c:	7c 0e       	ld.w	lr,lr[0x0]
8001286e:	f4 0b 09 2e 	st.w	r10[r11<<0x2],lr
			txSchedule.AvailableInstanceCount -= 1;
80012872:	49 db       	lddpc	r11,800128e4 <reserveTxInstance+0xd0>
80012874:	20 19       	sub	r9,1
80012876:	97 09       	st.w	r11[0x0],r9
80012878:	76 12       	ld.w	r2,r11[0x4]
8001287a:	f0 04 15 05 	lsl	r4,r8,0x5
8001287e:	2f 84       	sub	r4,-8
80012880:	14 04       	add	r4,r10
80012882:	30 06       	mov	r6,0
							txSchedule.AvailableBlockCount -= 1;
							break;
						}
					}
				}else{                   //Mark end of list.
					TxInstancePool[instanceIndex].BlockIndex[i] = TXBLOCKBOUND;
80012884:	31 01       	mov	r1,16
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
			txSchedule.AvailableInstanceCount -= 1;
			for (i=0; i<MAXPHYBLOCKS; i++){
				if (i < BlocksNeeded){   //Still looking.
					for (blockIndex=0; blockIndex<TXPOOLSIZE; blockIndex++){
						if (TxBlockReservation[blockIndex] == TXINSTANCESBOUND){
80012886:	49 b3       	lddpc	r3,800128f0 <reserveTxInstance+0xdc>
80012888:	30 4a       	mov	r10,4
8001288a:	e6 c0 ff ff 	sub	r0,r3,-1
//with the number of requested fragment blocks.
//If successful, it will return an Index
//to the Instance (<TXINSTANCESBOUND). If unsuccessful,
//it will return == TXINSTANCESBOUND. The requesting routine
//must check this!
U8 reserveTxInstance(int BlocksNeeded)
8001288e:	06 9e       	mov	lr,r3
80012890:	e6 01 00 07 	add	r7,r3,r1
		if (TxInstancePool[instanceIndex].behavior == NULLINSTANCEBEHAVIOR){
			//Code gets here when the available instance is found.
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
			txSchedule.AvailableInstanceCount -= 1;
			for (i=0; i<MAXPHYBLOCKS; i++){
				if (i < BlocksNeeded){   //Still looking.
80012894:	0c 3c       	cp.w	r12,r6
80012896:	e0 8a 00 18 	brle	800128c6 <reserveTxInstance+0xb2>
					for (blockIndex=0; blockIndex<TXPOOLSIZE; blockIndex++){
						if (TxBlockReservation[blockIndex] == TXINSTANCESBOUND){
8001289a:	07 88       	ld.ub	r8,r3[0x0]
8001289c:	f4 08 18 00 	cp.b	r8,r10
800128a0:	c0 31       	brne	800128a6 <reserveTxInstance+0x92>
800128a2:	30 0b       	mov	r11,0
800128a4:	c0 88       	rjmp	800128b4 <reserveTxInstance+0xa0>
800128a6:	00 98       	mov	r8,r0
//with the number of requested fragment blocks.
//If successful, it will return an Index
//to the Instance (<TXINSTANCESBOUND). If unsuccessful,
//it will return == TXINSTANCESBOUND. The requesting routine
//must check this!
U8 reserveTxInstance(int BlocksNeeded)
800128a8:	f0 0e 01 0b 	sub	r11,r8,lr
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
			txSchedule.AvailableInstanceCount -= 1;
			for (i=0; i<MAXPHYBLOCKS; i++){
				if (i < BlocksNeeded){   //Still looking.
					for (blockIndex=0; blockIndex<TXPOOLSIZE; blockIndex++){
						if (TxBlockReservation[blockIndex] == TXINSTANCESBOUND){
800128ac:	11 89       	ld.ub	r9,r8[0x0]
800128ae:	f4 09 18 00 	cp.b	r9,r10
800128b2:	c0 61       	brne	800128be <reserveTxInstance+0xaa>
							TxBlockReservation[blockIndex] = instanceIndex;
800128b4:	e6 0b 0b 05 	st.b	r3[r11],r5
							TxInstancePool[instanceIndex].BlockIndex[i] = blockIndex;
800128b8:	89 0b       	st.w	r4[0x0],r11
							txSchedule.AvailableBlockCount -= 1;
800128ba:	20 12       	sub	r2,1
							break;
800128bc:	c0 68       	rjmp	800128c8 <reserveTxInstance+0xb4>
800128be:	2f f8       	sub	r8,-1
			//Code gets here when the available instance is found.
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
			txSchedule.AvailableInstanceCount -= 1;
			for (i=0; i<MAXPHYBLOCKS; i++){
				if (i < BlocksNeeded){   //Still looking.
					for (blockIndex=0; blockIndex<TXPOOLSIZE; blockIndex++){
800128c0:	0e 38       	cp.w	r8,r7
800128c2:	cf 31       	brne	800128a8 <reserveTxInstance+0x94>
800128c4:	c0 28       	rjmp	800128c8 <reserveTxInstance+0xb4>
							txSchedule.AvailableBlockCount -= 1;
							break;
						}
					}
				}else{                   //Mark end of list.
					TxInstancePool[instanceIndex].BlockIndex[i] = TXBLOCKBOUND;
800128c6:	89 01       	st.w	r4[0x0],r1
800128c8:	2f f6       	sub	r6,-1
800128ca:	2f c4       	sub	r4,-4
	for (instanceIndex=0; instanceIndex<TXINSTANCESIMPLEMENTED; instanceIndex++){
		if (TxInstancePool[instanceIndex].behavior == NULLINSTANCEBEHAVIOR){
			//Code gets here when the available instance is found.
			TxInstancePool[instanceIndex].RetryTime = theRxCirCtrlr.RxLinkCount;
			txSchedule.AvailableInstanceCount -= 1;
			for (i=0; i<MAXPHYBLOCKS; i++){
800128cc:	58 66       	cp.w	r6,6
800128ce:	ce 31       	brne	80012894 <reserveTxInstance+0x80>
800128d0:	48 58       	lddpc	r8,800128e4 <reserveTxInstance+0xd0>
800128d2:	91 12       	st.w	r8[0x4],r2
800128d4:	c0 58       	rjmp	800128de <reserveTxInstance+0xca>
	//If using AvailableInstanceCount and AvailableBlockCount, code should never
	//get here unless something is very wrong. If these tests are not used,
	//code will get here if allocation fails. Then should call releaseTxInstance.
	// if (instanceIndex < TXINSTANCESBOUND) releaseTxInstance(instanceIndex);
	//Here, something is very wrong:
	DontPanic = FALSE;
800128d6:	30 09       	mov	r9,0
800128d8:	48 78       	lddpc	r8,800128f4 <reserveTxInstance+0xe0>
800128da:	b0 89       	st.b	r8[0x0],r9
800128dc:	30 45       	mov	r5,4
	return TXINSTANCESBOUND;
}
800128de:	0a 9c       	mov	r12,r5
800128e0:	d8 32       	popm	r0-r7,pc
800128e2:	00 00       	add	r0,r0
800128e4:	00 00       	add	r0,r0
800128e6:	49 24       	lddpc	r4,8001292c <findTxInstance_byOpCode+0x34>
800128e8:	00 00       	add	r0,r0
800128ea:	38 64       	mov	r4,-122
800128ec:	00 00       	add	r0,r0
800128ee:	38 38       	mov	r8,-125
800128f0:	00 00       	add	r0,r0
800128f2:	28 24       	sub	r4,-126
800128f4:	00 00       	add	r0,r0
800128f6:	49 44       	lddpc	r4,80012944 <findTxInstance_byTransID+0x10>

800128f8 <findTxInstance_byOpCode>:

U8 findTxInstance_byOpCode(U16 opcode)
{
800128f8:	d4 01       	pushm	lr
800128fa:	18 9e       	mov	lr,r12
800128fc:	48 c8       	lddpc	r8,8001292c <findTxInstance_byOpCode+0x34>
800128fe:	30 0c       	mov	r12,0
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
			                                                         //Check for opcode.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.opcode == opcode) return i;
80012900:	48 cb       	lddpc	r11,80012930 <findTxInstance_byOpCode+0x38>

U8 findTxInstance_byOpCode(U16 opcode)
{
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
80012902:	30 4a       	mov	r10,4
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
80012904:	70 09       	ld.w	r9,r8[0x0]
80012906:	58 09       	cp.w	r9,0
80012908:	c0 90       	breq	8001291a <findTxInstance_byOpCode+0x22>
			                                                         //Check for opcode.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.opcode == opcode) return i;
8001290a:	70 29       	ld.w	r9,r8[0x8]
8001290c:	a7 69       	lsl	r9,0x6
8001290e:	2f f9       	sub	r9,-1
80012910:	f6 09 04 29 	ld.sh	r9,r11[r9<<0x2]
80012914:	fc 09 19 00 	cp.h	r9,lr
80012918:	c0 90       	breq	8001292a <findTxInstance_byOpCode+0x32>

U8 findTxInstance_byOpCode(U16 opcode)
{
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
8001291a:	f8 c9 ff ff 	sub	r9,r12,-1
8001291e:	f9 d9 c0 08 	bfextu	r12,r9,0x0,0x8
80012922:	2e 08       	sub	r8,-32
80012924:	f4 0c 18 00 	cp.b	r12,r10
80012928:	ce e1       	brne	80012904 <findTxInstance_byOpCode+0xc>
			                                                         //Check for opcode.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.opcode == opcode) return i;
		}
	}
	return 	TXINSTANCESBOUND;  //Return none found.
}
8001292a:	d8 02       	popm	pc
8001292c:	00 00       	add	r0,r0
8001292e:	38 64       	mov	r4,-122
80012930:	00 00       	add	r0,r0
80012932:	39 04       	mov	r4,-112

80012934 <findTxInstance_byTransID>:

U8 findTxInstance_byTransID(U16 TransID)
{
80012934:	d4 01       	pushm	lr
80012936:	18 9e       	mov	lr,r12
80012938:	48 c8       	lddpc	r8,80012968 <findTxInstance_byTransID+0x34>
8001293a:	30 0c       	mov	r12,0
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
			                                                         //Check for TransID.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.transactionID == TransID) return i;
8001293c:	48 cb       	lddpc	r11,8001296c <findTxInstance_byTransID+0x38>

U8 findTxInstance_byTransID(U16 TransID)
{
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
8001293e:	30 4a       	mov	r10,4
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
80012940:	70 09       	ld.w	r9,r8[0x0]
80012942:	58 09       	cp.w	r9,0
80012944:	c0 90       	breq	80012956 <findTxInstance_byTransID+0x22>
			                                                         //Check for TransID.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.transactionID == TransID) return i;
80012946:	70 29       	ld.w	r9,r8[0x8]
80012948:	a9 69       	lsl	r9,0x8
8001294a:	f6 09 00 09 	add	r9,r11,r9
8001294e:	92 69       	ld.sh	r9,r9[0xc]
80012950:	fc 09 19 00 	cp.h	r9,lr
80012954:	c0 90       	breq	80012966 <findTxInstance_byTransID+0x32>

U8 findTxInstance_byTransID(U16 TransID)
{
	U8 i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
80012956:	f8 c9 ff ff 	sub	r9,r12,-1
8001295a:	f9 d9 c0 08 	bfextu	r12,r9,0x0,0x8
8001295e:	2e 08       	sub	r8,-32
80012960:	f4 0c 18 00 	cp.b	r12,r10
80012964:	ce e1       	brne	80012940 <findTxInstance_byTransID+0xc>
			                                                         //Check for TransID.
			if (TxBufferPool[TxInstancePool[i].BlockIndex[0]].XNL.theXNL_Header.transactionID == TransID) return i;
		}
	}
	return 	TXINSTANCESBOUND;  //Return none found.
}
80012966:	d8 02       	popm	pc
80012968:	00 00       	add	r0,r0
8001296a:	38 64       	mov	r4,-122
8001296c:	00 00       	add	r0,r0
8001296e:	39 04       	mov	r4,-112

80012970 <findTxInstance_byTimeout>:

U8 findTxInstance_byTimeout(void)
{
80012970:	d4 01       	pushm	lr
	U8  i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
			//FG writes to RxLinkCount *should* be atomic. If not, could be FG/BG contention.
			if (theRxCirCtrlr.RxLinkCount - TxInstancePool[i].RetryTime < 0x7FFFFFFF) return i;
80012972:	48 d8       	lddpc	r8,800129a4 <findTxInstance_byTimeout+0x34>
80012974:	70 0b       	ld.w	r11,r8[0x0]
80012976:	48 d8       	lddpc	r8,800129a8 <findTxInstance_byTimeout+0x38>
80012978:	30 0c       	mov	r12,0

U8 findTxInstance_byTimeout(void)
{
	U8  i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
8001297a:	30 49       	mov	r9,4
		if (TxInstancePool[i].behavior > 0) {  //For non-Null behavior,
8001297c:	70 0a       	ld.w	r10,r8[0x0]
8001297e:	58 0a       	cp.w	r10,0
80012980:	c0 b0       	breq	80012996 <findTxInstance_byTimeout+0x26>
			//FG writes to RxLinkCount *should* be atomic. If not, could be FG/BG contention.
			if (theRxCirCtrlr.RxLinkCount - TxInstancePool[i].RetryTime < 0x7FFFFFFF) return i;
80012982:	70 1a       	ld.w	r10,r8[0x4]
80012984:	f6 0a 01 0a 	sub	r10,r11,r10
80012988:	e0 6e ff fe 	mov	lr,65534
8001298c:	ea 1e 7f ff 	orh	lr,0x7fff
80012990:	1c 3a       	cp.w	r10,lr
80012992:	e0 88 00 08 	brls	800129a2 <findTxInstance_byTimeout+0x32>

U8 findTxInstance_byTimeout(void)
{
	U8  i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){                    //Check each Instance.
80012996:	2f fc       	sub	r12,-1
80012998:	5c 5c       	castu.b	r12
8001299a:	2e 08       	sub	r8,-32
8001299c:	f2 0c 18 00 	cp.b	r12,r9
800129a0:	ce e1       	brne	8001297c <findTxInstance_byTimeout+0xc>
			//FG writes to RxLinkCount *should* be atomic. If not, could be FG/BG contention.
			if (theRxCirCtrlr.RxLinkCount - TxInstancePool[i].RetryTime < 0x7FFFFFFF) return i;
		}
	}
	return 	TXINSTANCESBOUND;  //Return none found.
}
800129a2:	d8 02       	popm	pc
800129a4:	00 00       	add	r0,r0
800129a6:	38 38       	mov	r8,-125
800129a8:	00 00       	add	r0,r0
800129aa:	38 64       	mov	r4,-122

800129ac <releaseTxInstance>:

void releaseTxInstance(U8 instanceIndex)
{
800129ac:	eb cd 40 c0 	pushm	r6-r7,lr
	U8  i;

	if (instanceIndex >= TXINSTANCESBOUND) return;
800129b0:	30 38       	mov	r8,3
800129b2:	f0 0c 18 00 	cp.b	r12,r8
800129b6:	e0 8b 00 46 	brhi	80012a42 <releaseTxInstance+0x96>
	//may be to mark this, and handle the deletion through garbage collection.
	//I'd need to set up the FG/BG semiphores differently for this.
	//Right now, I do not want to take the time to do this. Since this
	//really should never happen, and since time delays in BG really should not
	//cause any problems, I'm just using an ugly wait loop here.
	while (((TxInstancePool[instanceIndex].behavior) & FGOWNSBEHAVIOR) == FGOWNSBEHAVIOR);
800129ba:	f8 08 15 05 	lsl	r8,r12,0x5
800129be:	4a 39       	lddpc	r9,80012a48 <releaseTxInstance+0x9c>
800129c0:	f2 08 03 08 	ld.w	r8,r9[r8]
800129c4:	58 08       	cp.w	r8,0
800129c6:	c3 d5       	brlt	80012a40 <releaseTxInstance+0x94>

	for (i=0; i<MAXPHYBLOCKS; i++){
		if (TxInstancePool[instanceIndex].BlockIndex[i] != TXBLOCKBOUND){
800129c8:	f8 09 15 02 	lsl	r9,r12,0x2
800129cc:	2f f9       	sub	r9,-1
800129ce:	49 f8       	lddpc	r8,80012a48 <releaseTxInstance+0x9c>
800129d0:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
800129d4:	59 08       	cp.w	r8,16
800129d6:	c1 c1       	brne	80012a0e <releaseTxInstance+0x62>
800129d8:	c0 f8       	rjmp	800129f6 <releaseTxInstance+0x4a>
800129da:	72 0a       	ld.w	r10,r9[0x0]
800129dc:	59 0a       	cp.w	r10,16
800129de:	c0 41       	brne	800129e6 <releaseTxInstance+0x3a>
800129e0:	49 b9       	lddpc	r9,80012a4c <releaseTxInstance+0xa0>
800129e2:	93 18       	st.w	r9[0x4],r8
800129e4:	c0 98       	rjmp	800129f6 <releaseTxInstance+0x4a>
			TxBlockReservation[TxInstancePool[instanceIndex].BlockIndex[i]]
800129e6:	ee 0a 0b 0e 	st.b	r7[r10],lr
			                                            = TXINSTANCESBOUND;
			TxInstancePool[instanceIndex].BlockIndex[i] = TXBLOCKBOUND;
800129ea:	12 ab       	st.w	r9++,r11
		}
	}
	return 	TXINSTANCESBOUND;  //Return none found.
}

void releaseTxInstance(U8 instanceIndex)
800129ec:	2f f8       	sub	r8,-1
	//Right now, I do not want to take the time to do this. Since this
	//really should never happen, and since time delays in BG really should not
	//cause any problems, I'm just using an ugly wait loop here.
	while (((TxInstancePool[instanceIndex].behavior) & FGOWNSBEHAVIOR) == FGOWNSBEHAVIOR);

	for (i=0; i<MAXPHYBLOCKS; i++){
800129ee:	0c 38       	cp.w	r8,r6
800129f0:	cf 51       	brne	800129da <releaseTxInstance+0x2e>
800129f2:	49 79       	lddpc	r9,80012a4c <releaseTxInstance+0xa0>
800129f4:	93 18       	st.w	r9[0x4],r8
			txSchedule.AvailableBlockCount += 1;
		}else{  //We've removed all allocations.
			break;
		}
	}
	TxInstancePool[instanceIndex].behavior = NULLINSTANCEBEHAVIOR;
800129f6:	a5 7c       	lsl	r12,0x5
800129f8:	49 48       	lddpc	r8,80012a48 <releaseTxInstance+0x9c>
800129fa:	f0 0c 00 0c 	add	r12,r8,r12
800129fe:	30 08       	mov	r8,0
80012a00:	99 08       	st.w	r12[0x0],r8
	txSchedule.AvailableInstanceCount += 1;
80012a02:	49 38       	lddpc	r8,80012a4c <releaseTxInstance+0xa0>
80012a04:	70 09       	ld.w	r9,r8[0x0]
80012a06:	2f f9       	sub	r9,-1
80012a08:	91 09       	st.w	r8[0x0],r9
80012a0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	//cause any problems, I'm just using an ugly wait loop here.
	while (((TxInstancePool[instanceIndex].behavior) & FGOWNSBEHAVIOR) == FGOWNSBEHAVIOR);

	for (i=0; i<MAXPHYBLOCKS; i++){
		if (TxInstancePool[instanceIndex].BlockIndex[i] != TXBLOCKBOUND){
			TxBlockReservation[TxInstancePool[instanceIndex].BlockIndex[i]]
80012a0e:	30 4a       	mov	r10,4
80012a10:	49 09       	lddpc	r9,80012a50 <releaseTxInstance+0xa4>
80012a12:	f2 08 0b 0a 	st.b	r9[r8],r10
			                                            = TXINSTANCESBOUND;
			TxInstancePool[instanceIndex].BlockIndex[i] = TXBLOCKBOUND;
80012a16:	48 da       	lddpc	r10,80012a48 <releaseTxInstance+0x9c>
80012a18:	f8 08 15 02 	lsl	r8,r12,0x2
80012a1c:	2f f8       	sub	r8,-1
80012a1e:	31 09       	mov	r9,16
80012a20:	f4 08 09 39 	st.w	r10[r8<<0x3],r9
			txSchedule.AvailableBlockCount += 1;
80012a24:	48 a9       	lddpc	r9,80012a4c <releaseTxInstance+0xa0>
80012a26:	72 16       	ld.w	r6,r9[0x4]
80012a28:	ec c8 ff ff 	sub	r8,r6,-1
80012a2c:	93 18       	st.w	r9[0x4],r8
80012a2e:	f8 09 15 05 	lsl	r9,r12,0x5
80012a32:	2f 49       	sub	r9,-12
80012a34:	14 09       	add	r9,r10
		}
	}
	return 	TXINSTANCESBOUND;  //Return none found.
}

void releaseTxInstance(U8 instanceIndex)
80012a36:	2f a6       	sub	r6,-6
	//cause any problems, I'm just using an ugly wait loop here.
	while (((TxInstancePool[instanceIndex].behavior) & FGOWNSBEHAVIOR) == FGOWNSBEHAVIOR);

	for (i=0; i<MAXPHYBLOCKS; i++){
		if (TxInstancePool[instanceIndex].BlockIndex[i] != TXBLOCKBOUND){
			TxBlockReservation[TxInstancePool[instanceIndex].BlockIndex[i]]
80012a38:	48 67       	lddpc	r7,80012a50 <releaseTxInstance+0xa4>
80012a3a:	30 4e       	mov	lr,4
			                                            = TXINSTANCESBOUND;
			TxInstancePool[instanceIndex].BlockIndex[i] = TXBLOCKBOUND;
80012a3c:	31 0b       	mov	r11,16
80012a3e:	cc eb       	rjmp	800129da <releaseTxInstance+0x2e>
80012a40:	c0 08       	rjmp	80012a40 <releaseTxInstance+0x94>
80012a42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80012a46:	00 00       	add	r0,r0
80012a48:	00 00       	add	r0,r0
80012a4a:	38 64       	mov	r4,-122
80012a4c:	00 00       	add	r0,r0
80012a4e:	49 24       	lddpc	r4,80012a94 <sumTxInstance+0x10>
80012a50:	00 00       	add	r0,r0
80012a52:	28 24       	sub	r4,-126

80012a54 <garbageCollect>:
	TxInstancePool[instanceIndex].behavior = NULLINSTANCEBEHAVIOR;
	txSchedule.AvailableInstanceCount += 1;
}

void garbageCollect(void)
{
80012a54:	eb cd 40 c0 	pushm	r6-r7,lr
80012a58:	48 96       	lddpc	r6,80012a7c <garbageCollect+0x28>
80012a5a:	30 07       	mov	r7,0
80012a5c:	0e 9c       	mov	r12,r7
	U8  i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){ //Check each Instance.
		if (((TxInstancePool[i].behavior) & FGHANDSHAKEMASK)  == OKTOGARBAGECOLLECT) {  //Check for can delete.
80012a5e:	6c 08       	ld.w	r8,r6[0x0]
80012a60:	e6 18 e0 00 	andh	r8,0xe000,COH
80012a64:	fc 19 60 00 	movh	r9,0x6000
80012a68:	12 38       	cp.w	r8,r9
80012a6a:	c0 31       	brne	80012a70 <garbageCollect+0x1c>
			releaseTxInstance(i);
80012a6c:	f0 1f 00 05 	mcall	80012a80 <garbageCollect+0x2c>
80012a70:	2f f7       	sub	r7,-1
80012a72:	2e 06       	sub	r6,-32

void garbageCollect(void)
{
	U8  i;

	for (i = 0; i < TXINSTANCESIMPLEMENTED; i++){ //Check each Instance.
80012a74:	58 47       	cp.w	r7,4
80012a76:	cf 31       	brne	80012a5c <garbageCollect+0x8>
		if (((TxInstancePool[i].behavior) & FGHANDSHAKEMASK)  == OKTOGARBAGECOLLECT) {  //Check for can delete.
			releaseTxInstance(i);
		}
	}
}
80012a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80012a7c:	00 00       	add	r0,r0
80012a7e:	38 64       	mov	r4,-122
80012a80:	80 01       	ld.sh	r1,r0[0x0]
80012a82:	29 ac       	sub	r12,-102

80012a84 <sumTxInstance>:

void sumTxInstance(U8 instanceIndex)
{
80012a84:	eb cd 40 f8 	pushm	r3-r7,lr
	U32  indextofrag;
	S32  hWordswithinFrag;
	U32  indextohWord;
	U16 sumScratch;

	if (instanceIndex >= TXINSTANCESBOUND) return;
80012a88:	30 38       	mov	r8,3
80012a8a:	f0 0c 18 00 	cp.b	r12,r8
80012a8e:	e0 8b 00 3f 	brhi	80012b0c <sumTxInstance+0x88>

	for (fragwithinInstance=0; fragwithinInstance<MAXPHYBLOCKS; fragwithinInstance++){
		indextofrag = TxInstancePool[instanceIndex].BlockIndex[fragwithinInstance];
80012a92:	f8 09 15 02 	lsl	r9,r12,0x2
80012a96:	2f f9       	sub	r9,-1
80012a98:	49 e8       	lddpc	r8,80012b10 <sumTxInstance+0x8c>
80012a9a:	f0 09 03 3e 	ld.w	lr,r8[r9<<0x3]
		if (indextofrag != TXBLOCKBOUND){
80012a9e:	59 0e       	cp.w	lr,16
80012aa0:	c3 60       	breq	80012b0c <sumTxInstance+0x88>
80012aa2:	a5 7c       	lsl	r12,0x5
80012aa4:	f8 c5 ff f4 	sub	r5,r12,-12
80012aa8:	10 05       	add	r5,r8
80012aaa:	30 07       	mov	r7,0
			sumScratch = 0;
			hWordswithinFrag = ((TxBufferPool[indextofrag].MAC.theMAC_Header.phy_control) & 0x00FF) - 2;
80012aac:	49 a6       	lddpc	r6,80012b14 <sumTxInstance+0x90>
			releaseTxInstance(i);
		}
	}
}

void sumTxInstance(U8 instanceIndex)
80012aae:	0e 94       	mov	r4,r7
80012ab0:	30 23       	mov	r3,2
80012ab2:	c0 48       	rjmp	80012aba <sumTxInstance+0x36>
	U16 sumScratch;

	if (instanceIndex >= TXINSTANCESBOUND) return;

	for (fragwithinInstance=0; fragwithinInstance<MAXPHYBLOCKS; fragwithinInstance++){
		indextofrag = TxInstancePool[instanceIndex].BlockIndex[fragwithinInstance];
80012ab4:	0b 0e       	ld.w	lr,r5++
		if (indextofrag != TXBLOCKBOUND){
80012ab6:	59 0e       	cp.w	lr,16
80012ab8:	c2 a0       	breq	80012b0c <sumTxInstance+0x88>
			sumScratch = 0;
			hWordswithinFrag = ((TxBufferPool[indextofrag].MAC.theMAC_Header.phy_control) & 0x00FF) - 2;
80012aba:	fc 08 15 08 	lsl	r8,lr,0x8
80012abe:	ec 08 05 08 	ld.uh	r8,r6[r8]
80012ac2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80012ac6:	20 28       	sub	r8,2
			hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; //Round up.
80012ac8:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80012acc:	f2 08 00 08 	add	r8,r9,r8
80012ad0:	f0 0c 14 01 	asr	r12,r8,0x1
			indextohWord = 2;
			while (hWordswithinFrag>0){
80012ad4:	58 0c       	cp.w	r12,0
80012ad6:	e0 89 00 04 	brgt	80012ade <sumTxInstance+0x5a>
80012ada:	08 99       	mov	r9,r4
80012adc:	c0 f8       	rjmp	80012afa <sumTxInstance+0x76>
80012ade:	fc 0a 15 08 	lsl	r10,lr,0x8
80012ae2:	2f ca       	sub	r10,-4
80012ae4:	0c 0a       	add	r10,r6
			releaseTxInstance(i);
		}
	}
}

void sumTxInstance(U8 instanceIndex)
80012ae6:	2f ec       	sub	r12,-2
80012ae8:	08 99       	mov	r9,r4
80012aea:	06 98       	mov	r8,r3
			sumScratch = 0;
			hWordswithinFrag = ((TxBufferPool[indextofrag].MAC.theMAC_Header.phy_control) & 0x00FF) - 2;
			hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; //Round up.
			indextohWord = 2;
			while (hWordswithinFrag>0){
				sumScratch += TxBufferPool[indextofrag].u16[indextohWord];
80012aec:	15 1b       	ld.sh	r11,r10++
80012aee:	f6 09 00 09 	add	r9,r11,r9
80012af2:	5c 89       	casts.h	r9
				indextohWord     += 1;
80012af4:	2f f8       	sub	r8,-1
		if (indextofrag != TXBLOCKBOUND){
			sumScratch = 0;
			hWordswithinFrag = ((TxBufferPool[indextofrag].MAC.theMAC_Header.phy_control) & 0x00FF) - 2;
			hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; //Round up.
			indextohWord = 2;
			while (hWordswithinFrag>0){
80012af6:	18 38       	cp.w	r8,r12
80012af8:	cf a1       	brne	80012aec <sumTxInstance+0x68>
				sumScratch += TxBufferPool[indextofrag].u16[indextohWord];
				indextohWord     += 1;
				hWordswithinFrag -= 1;
			}
			TxBufferPool[indextofrag].XNL.theMAC_Header.checksumspacesaver = -sumScratch;
80012afa:	fc 08 15 08 	lsl	r8,lr,0x8
80012afe:	ec 08 00 08 	add	r8,r6,r8
80012b02:	5c 39       	neg	r9
80012b04:	b0 19       	st.h	r8[0x2],r9
	U32  indextohWord;
	U16 sumScratch;

	if (instanceIndex >= TXINSTANCESBOUND) return;

	for (fragwithinInstance=0; fragwithinInstance<MAXPHYBLOCKS; fragwithinInstance++){
80012b06:	2f f7       	sub	r7,-1
80012b08:	58 67       	cp.w	r7,6
80012b0a:	cd 51       	brne	80012ab4 <sumTxInstance+0x30>
80012b0c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80012b10:	00 00       	add	r0,r0
80012b12:	38 64       	mov	r4,-122
80012b14:	00 00       	add	r0,r0
80012b16:	39 04       	mov	r4,-112

80012b18 <depleteAProcessedMessage>:
	}
}

void depleteAProcessedMessage(void)
{
	theRxCirCtrlr.RxXNL_ProcessWaitingIndex =
80012b18:	48 58       	lddpc	r8,80012b2c <depleteAProcessedMessage+0x14>
80012b1a:	f1 09 00 14 	ld.sh	r9,r8[20]
80012b1e:	2f f9       	sub	r9,-1
80012b20:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80012b24:	f1 59 00 14 	st.h	r8[20],r9
		((theRxCirCtrlr.RxXNL_ProcessWaitingIndex) + 1) & RXCIRBUFFERFRAGWRAP;
}
80012b28:	5e fc       	retal	r12
80012b2a:	00 00       	add	r0,r0
80012b2c:	00 00       	add	r0,r0
80012b2e:	38 38       	mov	r8,-125

80012b30 <encipher>:
// This code will not compile without a valid value assigned to authKey[].

void encipher(U32 *const v,
		      U32 *const w,
	    const U32 *const k)
{
80012b30:	eb cd 40 f8 	pushm	r3-r7,lr
	 register U32 y=v[0], z=v[1], sum=0;
80012b34:	78 09       	ld.w	r9,r12[0x0]
80012b36:	78 18       	ld.w	r8,r12[0x4]
	 register U32 delta= authDelta;
// NOTE: Delta available only to licensed MOTOTRBO developers.
// This code will not compile without a valid value assigned to delta.
	 register U32 a=k[0], b=k[1], c=k[2], d=k[3];
80012b38:	74 03       	ld.w	r3,r10[0x0]
80012b3a:	74 14       	ld.w	r4,r10[0x4]
80012b3c:	74 25       	ld.w	r5,r10[0x8]
80012b3e:	74 36       	ld.w	r6,r10[0xc]
80012b40:	30 0a       	mov	r10,0
	 register U32 n=32;

	 while(n-->0)
	 {
	 sum += delta;
80012b42:	e0 6c 79 b9 	mov	r12,31161
80012b46:	ea 1c 9e 37 	orh	r12,0x9e37
80012b4a:	18 0a       	add	r10,r12
	 y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80012b4c:	f4 08 00 07 	add	r7,r10,r8
80012b50:	f0 0e 15 04 	lsl	lr,r8,0x4
80012b54:	06 0e       	add	lr,r3
80012b56:	ef ee 20 0e 	eor	lr,r7,lr
80012b5a:	f0 07 16 05 	lsr	r7,r8,0x5
80012b5e:	08 07       	add	r7,r4
80012b60:	0e 5e       	eor	lr,r7
80012b62:	1c 09       	add	r9,lr
	 z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80012b64:	f2 07 15 04 	lsl	r7,r9,0x4
80012b68:	0a 07       	add	r7,r5
80012b6a:	f2 0e 16 05 	lsr	lr,r9,0x5
80012b6e:	0c 0e       	add	lr,r6
80012b70:	ef ee 20 0e 	eor	lr,r7,lr
80012b74:	f2 0a 00 07 	add	r7,r9,r10
80012b78:	0e 5e       	eor	lr,r7
80012b7a:	1c 08       	add	r8,lr
// NOTE: Delta available only to licensed MOTOTRBO developers.
// This code will not compile without a valid value assigned to delta.
	 register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	 register U32 n=32;

	 while(n-->0)
80012b7c:	e0 6e 37 20 	mov	lr,14112
80012b80:	ea 1e c6 ef 	orh	lr,0xc6ef
80012b84:	1c 3a       	cp.w	r10,lr
80012b86:	ce 21       	brne	80012b4a <encipher+0x1a>
	 sum += delta;
	 y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
	 z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
	 }

	 w[0]=y; w[1]=z;
80012b88:	97 09       	st.w	r11[0x0],r9
80012b8a:	97 18       	st.w	r11[0x4],r8
 }
80012b8c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

80012b90 <ResetRxMedia>:

void ResetRxMedia(void)
{
	U32 i;
	theRxMediaCtrlr.RxMediaState = BGFORCERESET;
	theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
80012b90:	30 09       	mov	r9,0
80012b92:	48 78       	lddpc	r8,80012bac <ResetRxMedia+0x1c>
80012b94:	91 19       	st.w	r8[0x4],r9
80012b96:	48 78       	lddpc	r8,80012bb0 <ResetRxMedia+0x20>
	 }

	 w[0]=y; w[1]=z;
 }

void ResetRxMedia(void)
80012b98:	f0 ca d8 00 	sub	r10,r8,-10240
{
	U32 i;
	theRxMediaCtrlr.RxMediaState = BGFORCERESET;
	theRxMediaCtrlr.RxMedia_IsFillingNext16 = 0;
	for (i=0; i<RXMEDIABUFFERSIZE; i++) RxMediaBuffer[i] = 0;
80012b9c:	10 b9       	st.h	r8++,r9
80012b9e:	14 38       	cp.w	r8,r10
80012ba0:	cf e1       	brne	80012b9c <ResetRxMedia+0xc>
	theRxMediaCtrlr.RxMediaState = WAITINGABAB;
80012ba2:	30 09       	mov	r9,0
80012ba4:	48 28       	lddpc	r8,80012bac <ResetRxMedia+0x1c>
80012ba6:	91 09       	st.w	r8[0x0],r9
}
80012ba8:	5e fc       	retal	r12
80012baa:	00 00       	add	r0,r0
80012bac:	00 00       	add	r0,r0
80012bae:	00 0c       	add	r12,r0
80012bb0:	00 00       	add	r0,r0
80012bb2:	00 1e       	sub	lr,r0

80012bb4 <initXNL>:



void initXNL(void)
{
80012bb4:	eb cd 40 80 	pushm	r7,lr
	int i;
	U8 masterQuery;

	ResetRxMedia();
80012bb8:	f0 1f 00 30 	mcall	80012c78 <initXNL+0xc4>
	theRxCirCtrlr.theRxLink_State = WAITINGFORHEADER;
80012bbc:	4b 09       	lddpc	r9,80012c7c <initXNL+0xc8>
80012bbe:	30 08       	mov	r8,0
80012bc0:	93 28       	st.w	r9[0x8],r8
	theRxCirCtrlr.RxLinkCount =                  0;
80012bc2:	93 08       	st.w	r9[0x0],r8
	theRxCirCtrlr.RxXNL_IsFillingMessageIndex =  0;
80012bc4:	f3 58 00 10 	st.h	r9[16],r8
	theRxCirCtrlr.RxXNL_IsFillingNextU16 =       0;
80012bc8:	f3 58 00 12 	st.h	r9[18],r8
	theRxCirCtrlr.RxXNL_ProcessWaitingIndex =    0;
80012bcc:	f3 58 00 14 	st.h	r9[20],r8
	theXNL_Ctrlr.XNL_State = XNL_UNCONNECTEDWAITINGSTATUS;
80012bd0:	4a c9       	lddpc	r9,80012c80 <initXNL+0xcc>
80012bd2:	93 38       	st.w	r9[0xc],r8
	theXNL_Ctrlr.isIncomingMessage =         FALSE;
80012bd4:	f3 68 00 10 	st.b	r9[16],r8
80012bd8:	4a b8       	lddpc	r8,80012c84 <initXNL+0xd0>
	theRxMediaCtrlr.RxMediaState = WAITINGABAB;
}



void initXNL(void)
80012bda:	f0 ca ff f0 	sub	r10,r8,-16
	  //Each entry is assigned to one of the available Instances (threads).
	  //There are TXINSTANCESIMPLEMENTED implemented instances,
	  //enabling TXINSTANCESIMPLEMENTED independent Tx mesage threads.
	  //Initially each TxBlockReservation entry is set to
	  //TXINSTANCESBOUND (== TXINSTANCESIMPLEMENTED), marking the block as available.
	  for (i=0; i<TXPOOLSIZE; i++) TxBlockReservation[i] = TXINSTANCESBOUND;
80012bde:	30 49       	mov	r9,4
80012be0:	10 c9       	st.b	r8++,r9
80012be2:	14 38       	cp.w	r8,r10
80012be4:	cf e1       	brne	80012be0 <initXNL+0x2c>

	  txSchedule.AvailableBlockCount = TXPOOLSIZE;
80012be6:	4a 98       	lddpc	r8,80012c88 <initXNL+0xd4>
80012be8:	31 09       	mov	r9,16
80012bea:	91 19       	st.w	r8[0x4],r9
	  //TxInstancePool has TXINSTANCESIMPLEMENTED entries, [0,1...TXINSTANCESIMPLEMENTED-1],
	  //one for ack available Tx Instance (thread).
	  //Each Instance State is initially set to NULLINSTANCESTATE,
	  //flagging it as available.
	  for (i=0; i<TXINSTANCESIMPLEMENTED; i++)
		  TxInstancePool[i].behavior = NULLINSTANCEBEHAVIOR;
80012bec:	4a 8a       	lddpc	r10,80012c8c <initXNL+0xd8>
80012bee:	30 09       	mov	r9,0
80012bf0:	95 09       	st.w	r10[0x0],r9
80012bf2:	95 89       	st.w	r10[0x20],r9
80012bf4:	f5 49 00 40 	st.w	r10[64],r9
80012bf8:	f5 49 00 60 	st.w	r10[96],r9

	  txSchedule.AvailableInstanceCount = TXINSTANCESIMPLEMENTED;
80012bfc:	30 47       	mov	r7,4
80012bfe:	91 07       	st.w	r8[0x0],r7

	  //On initialization, the Tx scheduler is forced to TXINSTANCESBOUND,
	  //indicating that none of the available threads are scheduled.
	  //The FG will continually transmit the MAC Idle message.
	  txSchedule.CurrentBlockIndex = TXINSTANCESBOUND;
80012c00:	91 57       	st.w	r8[0x14],r7
	  txSchedule.NextWaitingIndex  = TXINSTANCESBOUND;
80012c02:	91 77       	st.w	r8[0x1c],r7
	  txSchedule.TxLinkState = IDLEWAITINGSCHEDULE;
80012c04:	91 29       	st.w	r8[0x8],r9
	  // Development Guide.
	  //
	  // This code provides for this retry by creating an intance of the DEVICE_MASTER_QUERY
	  // message, but not sending it. Should the MASTER_STATUS_BRDCST not be received
	  // before the retry timout, the DEVICE_MASTER_QUERY will then be sent.
	  masterQuery = reserveTxInstance(DEVICE_MASTER_QUERY_BLOCK_COUNT);
80012c06:	30 1c       	mov	r12,1
80012c08:	f0 1f 00 22 	mcall	80012c90 <initXNL+0xdc>
	  if (masterQuery == TXINSTANCESBOUND){ //Good practice to test and recover.
80012c0c:	ee 0c 18 00 	cp.b	r12,r7
80012c10:	c0 61       	brne	80012c1c <initXNL+0x68>
		  DontPanic = FALSE;  //We just started, Panic!
80012c12:	30 09       	mov	r9,0
80012c14:	4a 08       	lddpc	r8,80012c94 <initXNL+0xe0>
80012c16:	b0 89       	st.b	r8[0x0],r9
		  return;
80012c18:	e3 cd 80 80 	ldm	sp++,r7,pc
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
	     TxBufferPool[TxInstancePool[masterQuery].BlockIndex[0]].u16[i]
80012c1c:	18 97       	mov	r7,r12
80012c1e:	f8 09 15 02 	lsl	r9,r12,0x2
80012c22:	2f f9       	sub	r9,-1
80012c24:	49 a8       	lddpc	r8,80012c8c <initXNL+0xd8>
80012c26:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80012c2a:	49 c8       	lddpc	r8,80012c98 <initXNL+0xe4>
80012c2c:	f8 0a 15 08 	lsl	r10,r12,0x8
80012c30:	49 b9       	lddpc	r9,80012c9c <initXNL+0xe8>
80012c32:	f4 09 00 09 	add	r9,r10,r9
	theRxMediaCtrlr.RxMediaState = WAITINGABAB;
}



void initXNL(void)
80012c36:	f0 cb ff f0 	sub	r11,r8,-16
		  DontPanic = FALSE;  //We just started, Panic!
		  return;
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
	     TxBufferPool[TxInstancePool[masterQuery].BlockIndex[0]].u16[i]
80012c3a:	11 1a       	ld.sh	r10,r8++
80012c3c:	12 ba       	st.h	r9++,r10
	  if (masterQuery == TXINSTANCESBOUND){ //Good practice to test and recover.
		  DontPanic = FALSE;  //We just started, Panic!
		  return;
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
80012c3e:	16 38       	cp.w	r8,r11
80012c40:	cf d1       	brne	80012c3a <initXNL+0x86>
	     TxBufferPool[TxInstancePool[masterQuery].BlockIndex[0]].u16[i]
	     = DEVICE_GENERIC_PROTO[i];

	  //Insert opcode.
	  TxBufferPool[TxInstancePool[masterQuery].BlockIndex[0]].XNL.theXNL_Header.opcode
80012c42:	a7 6c       	lsl	r12,0x6
80012c44:	2f fc       	sub	r12,-1
80012c46:	30 39       	mov	r9,3
80012c48:	49 58       	lddpc	r8,80012c9c <initXNL+0xe8>
80012c4a:	f0 0c 0a 29 	st.h	r8[r12<<0x2],r9
	    = XNL_DEVICE_MASTER_QUERY;

	  //fill in checksums.
	  sumTxInstance(masterQuery);
80012c4e:	0e 9c       	mov	r12,r7
80012c50:	f0 1f 00 14 	mcall	80012ca0 <initXNL+0xec>

	  //Schedule in future.
	  TxInstancePool[masterQuery].RetryTime += STANDARDTIMEOUT;
80012c54:	48 e8       	lddpc	r8,80012c8c <initXNL+0xd8>
80012c56:	ee 09 15 03 	lsl	r9,r7,0x3
80012c5a:	2f f9       	sub	r9,-1
80012c5c:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80012c60:	f4 ca f0 60 	sub	r10,r10,-4000
80012c64:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	  TxInstancePool[masterQuery].behavior = TXXNLCTRLPROTO;
80012c68:	a5 77       	lsl	r7,0x5
80012c6a:	e0 79 00 06 	mov	r9,65542
80012c6e:	f0 07 09 09 	st.w	r8[r7],r9
80012c72:	e3 cd 80 80 	ldm	sp++,r7,pc
80012c76:	00 00       	add	r0,r0
80012c78:	80 01       	ld.sh	r1,r0[0x0]
80012c7a:	2b 90       	sub	r0,-71
80012c7c:	00 00       	add	r0,r0
80012c7e:	38 38       	mov	r8,-125
80012c80:	00 00       	add	r0,r0
80012c82:	38 50       	mov	r0,-123
80012c84:	00 00       	add	r0,r0
80012c86:	28 24       	sub	r4,-126
80012c88:	00 00       	add	r0,r0
80012c8a:	49 24       	lddpc	r4,80012cd0 <processXNL_MASTER_STATUS_BRDCST+0x2c>
80012c8c:	00 00       	add	r0,r0
80012c8e:	38 64       	mov	r4,-122
80012c90:	80 01       	ld.sh	r1,r0[0x0]
80012c92:	28 14       	sub	r4,-127
80012c94:	00 00       	add	r0,r0
80012c96:	49 44       	lddpc	r4,80012ce4 <processXNL_MASTER_STATUS_BRDCST+0x40>
80012c98:	80 01       	ld.sh	r1,r0[0x0]
80012c9a:	3e 50       	mov	r0,-27
80012c9c:	00 00       	add	r0,r0
80012c9e:	39 04       	mov	r4,-112
80012ca0:	80 01       	ld.sh	r1,r0[0x0]
80012ca2:	2a 84       	sub	r4,-88

80012ca4 <processXNL_MASTER_STATUS_BRDCST>:
}

void processXNL_MASTER_STATUS_BRDCST(void)
{
80012ca4:	eb cd 40 80 	pushm	r7,lr
	  //determined and that non-master devices can now connect. The data payload for this
	  //message will contain the XNL version as well as the logical device identifier for the
	  //master device. The last field in the payload contains a flag that indicates whether or not
	  //an XNL_DATA_MSG has been sent out. This will indicate to a connecting device that it
	  //has missed messages. The XNL header will contain the masters XNL address. 5.4.1
	  theXNL_Ctrlr.XNL_MasterAddress = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.source;
80012ca8:	4a e7       	lddpc	r7,80012d60 <processXNL_MASTER_STATUS_BRDCST+0xbc>
80012caa:	4a f8       	lddpc	r8,80012d64 <processXNL_MASTER_STATUS_BRDCST+0xc0>
80012cac:	70 18       	ld.w	r8,r8[0x4]
80012cae:	90 58       	ld.sh	r8,r8[0xa]
80012cb0:	ae 08       	st.h	r7[0x0],r8
    //Could extract here Minor XNL Protocol Version Number.
    //Could extract here Major XNL Protocol Version Number.
    //Could extract here Master Logical Identifier.
    //Could extract here Message Sent Boolean.
	  releaseTxInstance(findTxInstance_byOpCode(XNL_DEVICE_MASTER_QUERY));
80012cb2:	30 3c       	mov	r12,3
80012cb4:	f0 1f 00 2d 	mcall	80012d68 <processXNL_MASTER_STATUS_BRDCST+0xc4>
80012cb8:	f0 1f 00 2d 	mcall	80012d6c <processXNL_MASTER_STATUS_BRDCST+0xc8>
	  theXNL_Ctrlr.XNL_State = XNL_UNCONNECTEDWAITINGAUTHKEY;
80012cbc:	30 1c       	mov	r12,1
80012cbe:	8f 3c       	st.w	r7[0xc],r12

	  //This message is sent by all non-master devices in order to get the authentication key to
	  //be used when establishing a connection. This message contains no payload data.
	  //XCMP/XNL Development Guide 5.4.3
	  theInstance = reserveTxInstance(DEVICE_AUTH_KEY_REQUEST_BLOCK_COUNT);
80012cc0:	f0 1f 00 2c 	mcall	80012d70 <processXNL_MASTER_STATUS_BRDCST+0xcc>
	  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
80012cc4:	30 48       	mov	r8,4
80012cc6:	f0 0c 18 00 	cp.b	r12,r8
80012cca:	c0 61       	brne	80012cd6 <processXNL_MASTER_STATUS_BRDCST+0x32>
	    DontPanic = FALSE;  //We just started, Panic!
80012ccc:	30 09       	mov	r9,0
80012cce:	4a a8       	lddpc	r8,80012d74 <processXNL_MASTER_STATUS_BRDCST+0xd0>
80012cd0:	b0 89       	st.b	r8[0x0],r9
	  	return;
80012cd2:	e3 cd 80 80 	ldm	sp++,r7,pc
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
	  	    TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012cd6:	18 97       	mov	r7,r12
80012cd8:	f8 09 15 02 	lsl	r9,r12,0x2
80012cdc:	2f f9       	sub	r9,-1
80012cde:	4a 78       	lddpc	r8,80012d78 <processXNL_MASTER_STATUS_BRDCST+0xd4>
80012ce0:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80012ce4:	4a 68       	lddpc	r8,80012d7c <processXNL_MASTER_STATUS_BRDCST+0xd8>
80012ce6:	f8 0a 15 08 	lsl	r10,r12,0x8
80012cea:	4a 69       	lddpc	r9,80012d80 <processXNL_MASTER_STATUS_BRDCST+0xdc>
80012cec:	f4 09 00 09 	add	r9,r10,r9
	  //Schedule in future.
	  TxInstancePool[masterQuery].RetryTime += STANDARDTIMEOUT;
	  TxInstancePool[masterQuery].behavior = TXXNLCTRLPROTO;
}

void processXNL_MASTER_STATUS_BRDCST(void)
80012cf0:	f0 cb ff f0 	sub	r11,r8,-16
	    DontPanic = FALSE;  //We just started, Panic!
	  	return;
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
	  	    TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012cf4:	11 1a       	ld.sh	r10,r8++
80012cf6:	12 ba       	st.h	r9++,r10
	  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
	    DontPanic = FALSE;  //We just started, Panic!
	  	return;
	  }

	  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
80012cf8:	16 38       	cp.w	r8,r11
80012cfa:	cf d1       	brne	80012cf4 <processXNL_MASTER_STATUS_BRDCST+0x50>
	  	    TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
	  	    = DEVICE_GENERIC_PROTO[i];

	  //Insert opcode.
	  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode
80012cfc:	4a 18       	lddpc	r8,80012d80 <processXNL_MASTER_STATUS_BRDCST+0xdc>
80012cfe:	f8 09 15 06 	lsl	r9,r12,0x6
80012d02:	2f f9       	sub	r9,-1
80012d04:	30 4a       	mov	r10,4
80012d06:	f0 09 0a 2a 	st.h	r8[r9<<0x2],r10
	      	  = XNL_DEVICE_AUTH_KEY_REQUEST;

	  //Use actual Master address.
	  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination
80012d0a:	a5 7c       	lsl	r12,0x5
80012d0c:	2f fc       	sub	r12,-1
80012d0e:	49 59       	lddpc	r9,80012d60 <processXNL_MASTER_STATUS_BRDCST+0xbc>
80012d10:	92 09       	ld.sh	r9,r9[0x0]
80012d12:	f0 0c 0a 39 	st.h	r8[r12<<0x3],r9
	  = theXNL_Ctrlr.XNL_MasterAddress;

	  //fill in checksums.
	  sumTxInstance(theInstance);
80012d16:	0e 9c       	mov	r12,r7
80012d18:	f0 1f 00 1b 	mcall	80012d84 <processXNL_MASTER_STATUS_BRDCST+0xe0>

	  //Attempt to schedule transmission.
	  //Scheduling *should* be immediate here as we've just started up.
	  //Failure to get immediate scheduling here may be concern for Panic.
	  if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
80012d1c:	49 b8       	lddpc	r8,80012d88 <processXNL_MASTER_STATUS_BRDCST+0xe4>
80012d1e:	70 78       	ld.w	r8,r8[0x1c]
80012d20:	58 48       	cp.w	r8,4
80012d22:	c1 61       	brne	80012d4e <processXNL_MASTER_STATUS_BRDCST+0xaa>
		  //Immediate transmission allowed
		  TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
80012d24:	49 58       	lddpc	r8,80012d78 <processXNL_MASTER_STATUS_BRDCST+0xd4>
80012d26:	ee 09 15 03 	lsl	r9,r7,0x3
80012d2a:	2f f9       	sub	r9,-1
80012d2c:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80012d30:	f4 ca f0 60 	sub	r10,r10,-4000
80012d34:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
		  TxInstancePool[theInstance].behavior = OWNEDXNLCTRLPRPTO;
80012d38:	ee 09 15 05 	lsl	r9,r7,0x5
80012d3c:	30 5a       	mov	r10,5
80012d3e:	ea 1a 80 01 	orh	r10,0x8001
80012d42:	f0 09 09 0a 	st.w	r8[r9],r10
		  txSchedule.NextWaitingIndex = theInstance;
80012d46:	49 18       	lddpc	r8,80012d88 <processXNL_MASTER_STATUS_BRDCST+0xe4>
80012d48:	91 77       	st.w	r8[0x1c],r7
80012d4a:	e3 cd 80 80 	ldm	sp++,r7,pc
	  }else{
		  //Leave RetryTime at current time.
		  TxInstancePool[theInstance].behavior = TXXNLCTRLPROTO;
80012d4e:	a5 77       	lsl	r7,0x5
80012d50:	e0 79 00 06 	mov	r9,65542
80012d54:	48 98       	lddpc	r8,80012d78 <processXNL_MASTER_STATUS_BRDCST+0xd4>
80012d56:	f0 07 09 09 	st.w	r8[r7],r9
80012d5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80012d5e:	00 00       	add	r0,r0
80012d60:	00 00       	add	r0,r0
80012d62:	38 50       	mov	r0,-123
80012d64:	00 00       	add	r0,r0
80012d66:	38 38       	mov	r8,-125
80012d68:	80 01       	ld.sh	r1,r0[0x0]
80012d6a:	28 f8       	sub	r8,-113
80012d6c:	80 01       	ld.sh	r1,r0[0x0]
80012d6e:	29 ac       	sub	r12,-102
80012d70:	80 01       	ld.sh	r1,r0[0x0]
80012d72:	28 14       	sub	r4,-127
80012d74:	00 00       	add	r0,r0
80012d76:	49 44       	lddpc	r4,80012dc4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x38>
80012d78:	00 00       	add	r0,r0
80012d7a:	38 64       	mov	r4,-122
80012d7c:	80 01       	ld.sh	r1,r0[0x0]
80012d7e:	3e 50       	mov	r0,-27
80012d80:	00 00       	add	r0,r0
80012d82:	39 04       	mov	r4,-112
80012d84:	80 01       	ld.sh	r1,r0[0x0]
80012d86:	2a 84       	sub	r4,-88
80012d88:	00 00       	add	r0,r0
80012d8a:	49 24       	lddpc	r4,80012dd0 <processXNL_DEVICE_AUTH_KEY_REPLY+0x44>

80012d8c <processXNL_DEVICE_AUTH_KEY_REPLY>:
	  }

}

void processXNL_DEVICE_AUTH_KEY_REPLY(void)
{
80012d8c:	eb cd 40 c0 	pushm	r6-r7,lr
80012d90:	20 4d       	sub	sp,16
  //The payload for XNL_DEVICE_AUTH_KEY_REPLY message is a temporary XNL address to use during the connection
  //process and an unencrypted 8 byte random number generated by the master. This
  //number should be encrypted by the receiving device and will be used to authenticate
  //the connection request. 5.4.4
  //Temporarily use temporary device address
  theXNL_Ctrlr.XNL_DeviceAddress
80012d92:	4c f7       	lddpc	r7,80012ecc <processXNL_DEVICE_AUTH_KEY_REPLY+0x140>
80012d94:	4c f8       	lddpc	r8,80012ed0 <processXNL_DEVICE_AUTH_KEY_REPLY+0x144>
80012d96:	70 18       	ld.w	r8,r8[0x4]
80012d98:	f1 09 00 10 	ld.sh	r9,r8[16]
80012d9c:	ae 19       	st.h	r7[0x2],r9
    = (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.TemporaryXNLAddress;

  //Get Array of values to be encrypted into an aligned 2X32bits.
  v_vector[0] = ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[0])<<24
80012d9e:	f1 3a 00 12 	ld.ub	r10,r8[18]
80012da2:	f1 39 00 13 	ld.ub	r9,r8[19]
80012da6:	b1 69       	lsl	r9,0x10
80012da8:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80012dac:	f1 3a 00 15 	ld.ub	r10,r8[21]
80012db0:	14 49       	or	r9,r10
80012db2:	f1 3a 00 14 	ld.ub	r10,r8[20]
80012db6:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80012dba:	50 29       	stdsp	sp[0x8],r9
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[1])<<16
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[2])<<8
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[3]);
  v_vector[1] = ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[4])<<24
80012dbc:	f1 3a 00 16 	ld.ub	r10,r8[22]
80012dc0:	f1 39 00 17 	ld.ub	r9,r8[23]
80012dc4:	b1 69       	lsl	r9,0x10
80012dc6:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80012dca:	f1 3a 00 19 	ld.ub	r10,r8[25]
80012dce:	14 49       	or	r9,r10
80012dd0:	f1 38 00 18 	ld.ub	r8,r8[24]
80012dd4:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80012dd8:	50 38       	stdsp	sp[0xc],r8
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[5])<<16
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[6])<<8
               | ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_AUTH_KEY_REPLY.UnencryptedAuthenticationValue[7]);

  encipher(&v_vector[0], &w_vector[0], &authKey[0]);
80012dda:	4b fa       	lddpc	r10,80012ed4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x148>
80012ddc:	1a 9b       	mov	r11,sp
80012dde:	fa cc ff f8 	sub	r12,sp,-8
80012de2:	f0 1f 00 3e 	mcall	80012ed8 <processXNL_DEVICE_AUTH_KEY_REPLY+0x14c>

  releaseTxInstance(findTxInstance_byOpCode(XNL_DEVICE_AUTH_KEY_REQUEST));
80012de6:	30 4c       	mov	r12,4
80012de8:	f0 1f 00 3d 	mcall	80012edc <processXNL_DEVICE_AUTH_KEY_REPLY+0x150>
80012dec:	f0 1f 00 3d 	mcall	80012ee0 <processXNL_DEVICE_AUTH_KEY_REPLY+0x154>
  	  theXNL_Ctrlr.XNL_State = XNL_UNCONNECTEDWAITINGDEVICECONN;
80012df0:	30 28       	mov	r8,2
80012df2:	8f 38       	st.w	r7[0xc],r8
  	//systems), a preferred address field should be used. Otherwise a value of 0x0000 should
  	//be used. For systems that contain both fixed address and dynamic address
  	//assignments, the preferred address cannot be guaranteed. The payload for this
  	//message also includes a device type value, authentication index, and the encrypted
  	//authentication value. XCMP/XNL Development Guide 5.4.5
  	theInstance = reserveTxInstance(DEVICE_CONN_REQUEST_BLOCK_COUNT);
80012df4:	30 1c       	mov	r12,1
80012df6:	f0 1f 00 3c 	mcall	80012ee4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x158>
  		  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
80012dfa:	30 48       	mov	r8,4
80012dfc:	f0 0c 18 00 	cp.b	r12,r8
80012e00:	c0 51       	brne	80012e0a <processXNL_DEVICE_AUTH_KEY_REPLY+0x7e>
  		    DontPanic = FALSE;  //We just started, Panic!
80012e02:	30 09       	mov	r9,0
80012e04:	4b 98       	lddpc	r8,80012ee8 <processXNL_DEVICE_AUTH_KEY_REPLY+0x15c>
80012e06:	b0 89       	st.b	r8[0x0],r9
  		  	return;
80012e08:	c5 f8       	rjmp	80012ec6 <processXNL_DEVICE_AUTH_KEY_REPLY+0x13a>
  		  }

  		for (i=0; i<DEVICE_CONN_REQUEST_U16_COUNT; i++)
  			 TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012e0a:	18 96       	mov	r6,r12
80012e0c:	f8 09 15 02 	lsl	r9,r12,0x2
80012e10:	2f f9       	sub	r9,-1
80012e12:	4b 78       	lddpc	r8,80012eec <processXNL_DEVICE_AUTH_KEY_REPLY+0x160>
80012e14:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80012e18:	4b 68       	lddpc	r8,80012ef0 <processXNL_DEVICE_AUTH_KEY_REPLY+0x164>
80012e1a:	f8 0a 15 08 	lsl	r10,r12,0x8
80012e1e:	4b 69       	lddpc	r9,80012ef4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x168>
80012e20:	f4 09 00 09 	add	r9,r10,r9
		  TxInstancePool[theInstance].behavior = TXXNLCTRLPROTO;
	  }

}

void processXNL_DEVICE_AUTH_KEY_REPLY(void)
80012e24:	f0 cb ff e4 	sub	r11,r8,-28
  		    DontPanic = FALSE;  //We just started, Panic!
  		  	return;
  		  }

  		for (i=0; i<DEVICE_CONN_REQUEST_U16_COUNT; i++)
  			 TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012e28:	11 1a       	ld.sh	r10,r8++
80012e2a:	12 ba       	st.h	r9++,r10
  		  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
  		    DontPanic = FALSE;  //We just started, Panic!
  		  	return;
  		  }

  		for (i=0; i<DEVICE_CONN_REQUEST_U16_COUNT; i++)
80012e2c:	16 38       	cp.w	r8,r11
80012e2e:	cf d1       	brne	80012e28 <processXNL_DEVICE_AUTH_KEY_REPLY+0x9c>
  			 TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
  			 = DEVICE_CONN_REQUEST_PROTO[i];

  		//Use actual Master address.
  		TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination
80012e30:	4b 17       	lddpc	r7,80012ef4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x168>
80012e32:	f8 09 15 05 	lsl	r9,r12,0x5
80012e36:	2f f9       	sub	r9,-1
80012e38:	4a 58       	lddpc	r8,80012ecc <processXNL_DEVICE_AUTH_KEY_REPLY+0x140>
80012e3a:	90 0a       	ld.sh	r10,r8[0x0]
80012e3c:	ee 09 0a 3a 	st.h	r7[r9<<0x3],r10
  		//will also be the same. So, they will be sending the same message here,
  		//and all will receive the same DEVICE_CONN_REPLY. Not real sure what's going
  		//to happen with multiple conrol heads, etc. One suspects the Rocket Scientists will
  		//eventually figure this out, and demand a transaction ID based on Device Type in
  		//the XNL_DEVICE_AUTH_KEY_REQUEST.
  		TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.source
80012e40:	ee 09 00 39 	add	r9,r7,r9<<0x3
80012e44:	90 18       	ld.sh	r8,r8[0x2]
80012e46:	b2 18       	st.h	r9[0x2],r8
  		  	 = theXNL_Ctrlr.XNL_DeviceAddress;

  		//We know encrypted array happens to be aligned to 32-bit boundary.
  		TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u32[5]
80012e48:	a9 6c       	lsl	r12,0x8
80012e4a:	ee 0c 00 0c 	add	r12,r7,r12
80012e4e:	40 08       	lddsp	r8,sp[0x0]
80012e50:	99 58       	st.w	r12[0x14],r8
  		                                                = w_vector[0];
  		TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u32[6]
80012e52:	40 18       	lddsp	r8,sp[0x4]
80012e54:	99 68       	st.w	r12[0x18],r8
  		  		                                        = w_vector[1];

  		//fill in checksums.
  	    sumTxInstance(theInstance);
80012e56:	0c 9c       	mov	r12,r6
80012e58:	f0 1f 00 28 	mcall	80012ef8 <processXNL_DEVICE_AUTH_KEY_REPLY+0x16c>

  	    //Presently the protocol enables, but does not require the Device to Authenticate the Master.
  	    //The present exchange is vulnerable to playback attack anyway, and only one Master
  	    //can be talking on the physical bus, this is kind of silly. I've included it here as just
  	    //another opportunity to check that the sequence has sanity.
  	    encipher(&w_vector[0], &v_vector[0], &authKey[0]);
80012e5c:	49 ea       	lddpc	r10,80012ed4 <processXNL_DEVICE_AUTH_KEY_REPLY+0x148>
80012e5e:	fa cb ff f8 	sub	r11,sp,-8
80012e62:	1a 9c       	mov	r12,sp
80012e64:	f0 1f 00 1d 	mcall	80012ed8 <processXNL_DEVICE_AUTH_KEY_REPLY+0x14c>
  	    //Squirrel away the result for comparison with value returned in DEVICE_CONN_REPLY.
  	    //This is not transmitted. Only using spare instance memory.
  	    TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u32[7]
80012e68:	ec 09 15 02 	lsl	r9,r6,0x2
80012e6c:	2f f9       	sub	r9,-1
80012e6e:	4a 08       	lddpc	r8,80012eec <processXNL_DEVICE_AUTH_KEY_REPLY+0x160>
80012e70:	f0 09 03 38 	ld.w	r8,r8[r9<<0x3]
80012e74:	f0 09 15 08 	lsl	r9,r8,0x8
80012e78:	ee 09 00 09 	add	r9,r7,r9
80012e7c:	40 2a       	lddsp	r10,sp[0x8]
80012e7e:	93 7a       	st.w	r9[0x1c],r10
  	    		                                           = v_vector[0];
  	    TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u32[8]
80012e80:	a9 68       	lsl	r8,0x8
80012e82:	2e 08       	sub	r8,-32
80012e84:	40 39       	lddsp	r9,sp[0xc]
80012e86:	ee 08 09 09 	st.w	r7[r8],r9

  	    //Attempt to schedule transmission.
  	  	//Scheduling *should* be immediate here as we've just started up.
  	  	//Failure to get immediate scheduling here may be concern for Panic.
  	  	//In general, a schedule failure can just wait for retry.
  	  	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
80012e8a:	49 d8       	lddpc	r8,80012efc <processXNL_DEVICE_AUTH_KEY_REPLY+0x170>
80012e8c:	70 78       	ld.w	r8,r8[0x1c]
80012e8e:	58 48       	cp.w	r8,4
80012e90:	c1 51       	brne	80012eba <processXNL_DEVICE_AUTH_KEY_REPLY+0x12e>
  	  		//Immediate transmission allowed
  	  	    TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
80012e92:	49 78       	lddpc	r8,80012eec <processXNL_DEVICE_AUTH_KEY_REPLY+0x160>
80012e94:	ec 09 15 03 	lsl	r9,r6,0x3
80012e98:	2f f9       	sub	r9,-1
80012e9a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80012e9e:	f4 ca f0 60 	sub	r10,r10,-4000
80012ea2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
  	  	    TxInstancePool[theInstance].behavior = OWNEDXNLCTRLPRPTO;
80012ea6:	ec 09 15 05 	lsl	r9,r6,0x5
80012eaa:	30 5a       	mov	r10,5
80012eac:	ea 1a 80 01 	orh	r10,0x8001
80012eb0:	f0 09 09 0a 	st.w	r8[r9],r10
  	  		txSchedule.NextWaitingIndex = theInstance;
80012eb4:	49 28       	lddpc	r8,80012efc <processXNL_DEVICE_AUTH_KEY_REPLY+0x170>
80012eb6:	91 76       	st.w	r8[0x1c],r6
80012eb8:	c0 78       	rjmp	80012ec6 <processXNL_DEVICE_AUTH_KEY_REPLY+0x13a>
  	  	}else{
  	  	    //Leave RetryTime at current time.
  	  	    TxInstancePool[theInstance].behavior = TXXNLCTRLPROTO;
80012eba:	a5 76       	lsl	r6,0x5
80012ebc:	e0 79 00 06 	mov	r9,65542
80012ec0:	48 b8       	lddpc	r8,80012eec <processXNL_DEVICE_AUTH_KEY_REPLY+0x160>
80012ec2:	f0 06 09 09 	st.w	r8[r6],r9
  	  	}

}
80012ec6:	2f cd       	sub	sp,-16
80012ec8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80012ecc:	00 00       	add	r0,r0
80012ece:	38 50       	mov	r0,-123
80012ed0:	00 00       	add	r0,r0
80012ed2:	38 38       	mov	r8,-125
80012ed4:	80 01       	ld.sh	r1,r0[0x0]
80012ed6:	3e 10       	mov	r0,-31
80012ed8:	80 01       	ld.sh	r1,r0[0x0]
80012eda:	2b 30       	sub	r0,-77
80012edc:	80 01       	ld.sh	r1,r0[0x0]
80012ede:	28 f8       	sub	r8,-113
80012ee0:	80 01       	ld.sh	r1,r0[0x0]
80012ee2:	29 ac       	sub	r12,-102
80012ee4:	80 01       	ld.sh	r1,r0[0x0]
80012ee6:	28 14       	sub	r4,-127
80012ee8:	00 00       	add	r0,r0
80012eea:	49 44       	lddpc	r4,80012f38 <processXNL_DEVICE_CONN_REPLY+0x38>
80012eec:	00 00       	add	r0,r0
80012eee:	38 64       	mov	r4,-122
80012ef0:	80 01       	ld.sh	r1,r0[0x0]
80012ef2:	3e 20       	mov	r0,-30
80012ef4:	00 00       	add	r0,r0
80012ef6:	39 04       	mov	r4,-112
80012ef8:	80 01       	ld.sh	r1,r0[0x0]
80012efa:	2a 84       	sub	r4,-88
80012efc:	00 00       	add	r0,r0
80012efe:	49 24       	lddpc	r4,80012f44 <processXNL_DEVICE_CONN_REPLY+0x44>

80012f00 <processXNL_DEVICE_CONN_REPLY>:

void processXNL_DEVICE_CONN_REPLY(void)
{
80012f00:	eb cd 40 80 	pushm	r7,lr
	//used as the upper byte of the transaction ID and an 8-byte encrypted value that the
	//device can use to authenticate the master. XCMP/XNL Development Guide 5.4.6


	//Test result code
	if((((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_CONN_REPLY.Result_Base)
80012f04:	4b b8       	lddpc	r8,80012ff0 <processXNL_DEVICE_CONN_REPLY+0xf0>
80012f06:	70 18       	ld.w	r8,r8[0x4]
80012f08:	f1 19 00 10 	ld.uh	r9,r8[16]
80012f0c:	12 9a       	mov	r10,r9
80012f0e:	e2 1a ff 00 	andl	r10,0xff00,COH
80012f12:	e0 4a 01 00 	cp.w	r10,256
80012f16:	c5 80       	breq	80012fc6 <processXNL_DEVICE_CONN_REPLY+0xc6>
	   & 0x0000FF00) != 0x00000100){
		//Rejected. The device must retry the authentication process at this point by sending out a
		//new AUTH_KEY_REQUEST message. XCMP/XNL Development Guide Section 5.2.3
		  releaseTxInstance(findTxInstance_byOpCode(XNL_DEVICE_CONN_REQUEST));
80012f18:	30 6c       	mov	r12,6
80012f1a:	f0 1f 00 37 	mcall	80012ff4 <processXNL_DEVICE_CONN_REPLY+0xf4>
80012f1e:	f0 1f 00 37 	mcall	80012ff8 <processXNL_DEVICE_CONN_REPLY+0xf8>
		  theXNL_Ctrlr.XNL_State = XNL_UNCONNECTEDWAITINGAUTHKEY;
80012f22:	30 1c       	mov	r12,1
80012f24:	4b 68       	lddpc	r8,80012ffc <processXNL_DEVICE_CONN_REPLY+0xfc>
80012f26:	91 3c       	st.w	r8[0xc],r12
		  theInstance = reserveTxInstance(DEVICE_AUTH_KEY_REQUEST_BLOCK_COUNT);
80012f28:	f0 1f 00 36 	mcall	80013000 <processXNL_DEVICE_CONN_REPLY+0x100>
		  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
80012f2c:	30 48       	mov	r8,4
80012f2e:	f0 0c 18 00 	cp.b	r12,r8
80012f32:	c0 61       	brne	80012f3e <processXNL_DEVICE_CONN_REPLY+0x3e>
		  	  DontPanic = FALSE;  //Panic!
80012f34:	30 09       	mov	r9,0
80012f36:	4b 48       	lddpc	r8,80013004 <processXNL_DEVICE_CONN_REPLY+0x104>
80012f38:	b0 89       	st.b	r8[0x0],r9
		  	  return;
80012f3a:	e3 cd 80 80 	ldm	sp++,r7,pc
		  }

		  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
		  	  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012f3e:	18 97       	mov	r7,r12
80012f40:	f8 09 15 02 	lsl	r9,r12,0x2
80012f44:	2f f9       	sub	r9,-1
80012f46:	4b 18       	lddpc	r8,80013008 <processXNL_DEVICE_CONN_REPLY+0x108>
80012f48:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80012f4c:	4b 08       	lddpc	r8,8001300c <processXNL_DEVICE_CONN_REPLY+0x10c>
80012f4e:	f8 0a 15 08 	lsl	r10,r12,0x8
80012f52:	4b 09       	lddpc	r9,80013010 <processXNL_DEVICE_CONN_REPLY+0x110>
80012f54:	f4 09 00 09 	add	r9,r10,r9
  	  	    TxInstancePool[theInstance].behavior = TXXNLCTRLPROTO;
  	  	}

}

void processXNL_DEVICE_CONN_REPLY(void)
80012f58:	f0 cb ff f0 	sub	r11,r8,-16
		  	  DontPanic = FALSE;  //Panic!
		  	  return;
		  }

		  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
		  	  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
80012f5c:	11 1a       	ld.sh	r10,r8++
80012f5e:	12 ba       	st.h	r9++,r10
		  if (theInstance == TXINSTANCESBOUND){ //Good practice to test and recover.
		  	  DontPanic = FALSE;  //Panic!
		  	  return;
		  }

		  for (i=0; i<DEVICE_GENERIC_U16_COUNT; i++)
80012f60:	16 38       	cp.w	r8,r11
80012f62:	cf d1       	brne	80012f5c <processXNL_DEVICE_CONN_REPLY+0x5c>
		  	  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u16[i]
		  	  	 = DEVICE_GENERIC_PROTO[i];

		  //Insert opcode.
		  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode
80012f64:	4a b8       	lddpc	r8,80013010 <processXNL_DEVICE_CONN_REPLY+0x110>
80012f66:	f8 09 15 06 	lsl	r9,r12,0x6
80012f6a:	2f f9       	sub	r9,-1
80012f6c:	30 4a       	mov	r10,4
80012f6e:	f0 09 0a 2a 	st.h	r8[r9<<0x2],r10
		  	   = XNL_DEVICE_AUTH_KEY_REQUEST;

		  //Use actual Master address.
		  TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination
80012f72:	a5 7c       	lsl	r12,0x5
80012f74:	2f fc       	sub	r12,-1
80012f76:	4a 29       	lddpc	r9,80012ffc <processXNL_DEVICE_CONN_REPLY+0xfc>
80012f78:	92 09       	ld.sh	r9,r9[0x0]
80012f7a:	f0 0c 0a 39 	st.h	r8[r12<<0x3],r9
		  	= theXNL_Ctrlr.XNL_MasterAddress;

		  //fill in checksums.
		  sumTxInstance(theInstance);
80012f7e:	0e 9c       	mov	r12,r7
80012f80:	f0 1f 00 25 	mcall	80013014 <processXNL_DEVICE_CONN_REPLY+0x114>

		  if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
80012f84:	4a 58       	lddpc	r8,80013018 <processXNL_DEVICE_CONN_REPLY+0x118>
80012f86:	70 78       	ld.w	r8,r8[0x1c]
80012f88:	58 48       	cp.w	r8,4
80012f8a:	c1 61       	brne	80012fb6 <processXNL_DEVICE_CONN_REPLY+0xb6>
			  //Immediate transmission allowed.
			  TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
80012f8c:	49 f8       	lddpc	r8,80013008 <processXNL_DEVICE_CONN_REPLY+0x108>
80012f8e:	ee 09 15 03 	lsl	r9,r7,0x3
80012f92:	2f f9       	sub	r9,-1
80012f94:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80012f98:	f4 ca f0 60 	sub	r10,r10,-4000
80012f9c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
			  TxInstancePool[theInstance].behavior = OWNEDXNLCTRLPRPTO;
80012fa0:	ee 09 15 05 	lsl	r9,r7,0x5
80012fa4:	30 5a       	mov	r10,5
80012fa6:	ea 1a 80 01 	orh	r10,0x8001
80012faa:	f0 09 09 0a 	st.w	r8[r9],r10
			  txSchedule.NextWaitingIndex = theInstance;
80012fae:	49 b8       	lddpc	r8,80013018 <processXNL_DEVICE_CONN_REPLY+0x118>
80012fb0:	91 77       	st.w	r8[0x1c],r7
80012fb2:	e3 cd 80 80 	ldm	sp++,r7,pc
		  }else{
			  //Leave RetryTime at current time.
			  TxInstancePool[theInstance].behavior = TXXNLCTRLPROTO;
80012fb6:	a5 77       	lsl	r7,0x5
80012fb8:	e0 79 00 06 	mov	r9,65542
80012fbc:	49 38       	lddpc	r8,80013008 <processXNL_DEVICE_CONN_REPLY+0x108>
80012fbe:	f0 07 09 09 	st.w	r8[r7],r9
80012fc2:	e3 cd 80 80 	ldm	sp++,r7,pc



	}else{ //connection accepted
		//Record Transaction ID Base
		theXNL_Ctrlr.XNL_TransactionIDBase
80012fc6:	48 e7       	lddpc	r7,80012ffc <processXNL_DEVICE_CONN_REPLY+0xfc>
80012fc8:	a9 69       	lsl	r9,0x8
80012fca:	ae 39       	st.h	r7[0x6],r9
		  = (((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_CONN_REPLY.Result_Base) & 0x000000FF) << 8;
		//Record Device Logical Address
		theXNL_Ctrlr.XNL_DeviceLogicalAddress
80012fcc:	f1 09 00 14 	ld.sh	r9,r8[20]
80012fd0:	ae 29       	st.h	r7[0x4],r9
			      = (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_CONN_REPLY.LogicalAddress;
		//Record permanent device address
	    theXNL_Ctrlr.XNL_DeviceAddress
80012fd2:	f1 08 00 12 	ld.sh	r8,r8[18]
80012fd6:	ae 18       	st.h	r7[0x2],r8
	      = (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_CONN_REPLY.XNLAddress;
	    //Initialize 3Bit  Rollover.
	    theXNL_Ctrlr.XNL_3BitRollover = 0x0000;
80012fd8:	30 08       	mov	r8,0
80012fda:	ae 48       	st.h	r7[0x8],r8
	    //((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentDEVICE_CONN_REPLY.EncryptedAuthenticationValue[i])
	    //!= (TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].u8[i+20]))
	    //	MasterAuthenticate = FAIL;
	    //}

	    releaseTxInstance(findTxInstance_byOpCode(XNL_DEVICE_CONN_REQUEST));
80012fdc:	30 6c       	mov	r12,6
80012fde:	f0 1f 00 06 	mcall	80012ff4 <processXNL_DEVICE_CONN_REPLY+0xf4>
80012fe2:	f0 1f 00 06 	mcall	80012ff8 <processXNL_DEVICE_CONN_REPLY+0xf8>
	    theXNL_Ctrlr.XNL_State = XNL_CONNECTED;
80012fe6:	30 38       	mov	r8,3
80012fe8:	8f 38       	st.w	r7[0xc],r8
80012fea:	e3 cd 80 80 	ldm	sp++,r7,pc
80012fee:	00 00       	add	r0,r0
80012ff0:	00 00       	add	r0,r0
80012ff2:	38 38       	mov	r8,-125
80012ff4:	80 01       	ld.sh	r1,r0[0x0]
80012ff6:	28 f8       	sub	r8,-113
80012ff8:	80 01       	ld.sh	r1,r0[0x0]
80012ffa:	29 ac       	sub	r12,-102
80012ffc:	00 00       	add	r0,r0
80012ffe:	38 50       	mov	r0,-123
80013000:	80 01       	ld.sh	r1,r0[0x0]
80013002:	28 14       	sub	r4,-127
80013004:	00 00       	add	r0,r0
80013006:	49 44       	lddpc	r4,80013054 <scheduleXNL_ACK+0x38>
80013008:	00 00       	add	r0,r0
8001300a:	38 64       	mov	r4,-122
8001300c:	80 01       	ld.sh	r1,r0[0x0]
8001300e:	3e 50       	mov	r0,-27
80013010:	00 00       	add	r0,r0
80013012:	39 04       	mov	r4,-112
80013014:	80 01       	ld.sh	r1,r0[0x0]
80013016:	2a 84       	sub	r4,-88
80013018:	00 00       	add	r0,r0
8001301a:	49 24       	lddpc	r4,80013060 <scheduleXNL_ACK+0x44>

8001301c <scheduleXNL_ACK>:
	}
}

Bool scheduleXNL_ACK(void)
{
8001301c:	eb cd 40 c0 	pushm	r6-r7,lr
	U8 theInstance;

	theInstance = reserveTxInstance(XNL_DATA_MSG_ACK_BLOCK_COUNT);
80013020:	30 1c       	mov	r12,1
80013022:	f0 1f 00 2d 	mcall	800130d4 <scheduleXNL_ACK+0xb8>
	if (theInstance == TXINSTANCESBOUND){ //Are we able to ACK?
80013026:	30 48       	mov	r8,4
80013028:	f0 0c 18 00 	cp.b	r12,r8
8001302c:	c0 31       	brne	80013032 <scheduleXNL_ACK+0x16>
8001302e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		  	return FALSE;
		  }
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theMAC_Header.phy_control = 0x400E;
80013032:	18 97       	mov	r7,r12
80013034:	f8 09 15 02 	lsl	r9,r12,0x2
80013038:	2f f9       	sub	r9,-1
8001303a:	4a 88       	lddpc	r8,800130d8 <scheduleXNL_ACK+0xbc>
8001303c:	f0 09 03 3a 	ld.w	r10,r8[r9<<0x3]
80013040:	4a 78       	lddpc	r8,800130dc <scheduleXNL_ACK+0xc0>
80013042:	f4 0b 15 08 	lsl	r11,r10,0x8
80013046:	f0 0b 00 0b 	add	r11,r8,r11
8001304a:	e0 69 40 0e 	mov	r9,16398
8001304e:	b6 09       	st.h	r11[0x0],r9

	//Turn around Flags.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.flags
	         = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.flags;
80013050:	4a 49       	lddpc	r9,800130e0 <scheduleXNL_ACK+0xc4>
80013052:	72 19       	ld.w	r9,r9[0x4]
		  	return FALSE;
		  }
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theMAC_Header.phy_control = 0x400E;

	//Turn around Flags.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.flags
80013054:	f4 0c 15 06 	lsl	r12,r10,0x6
80013058:	2f fc       	sub	r12,-1
8001305a:	f0 0c 00 2e 	add	lr,r8,r12<<0x2
8001305e:	92 36       	ld.sh	r6,r9[0x6]
80013060:	bc 16       	st.h	lr[0x2],r6
	         = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.flags;

	//Insert opcode.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode
80013062:	30 ce       	mov	lr,12
80013064:	f0 0c 0a 2e 	st.h	r8[r12<<0x2],lr
		      	  = XNL_DATA_MSG_ACK;

    //ACK Destination Address is Source of XNL_Message.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination
80013068:	a5 7a       	lsl	r10,0x5
8001306a:	2f fa       	sub	r10,-1
8001306c:	92 5c       	ld.sh	r12,r9[0xa]
8001306e:	f0 0a 0a 3c 	st.h	r8[r10<<0x3],r12
		  = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.source;

	//ACK Source Address is my address.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.source
80013072:	f0 0a 00 38 	add	r8,r8,r10<<0x3
80013076:	49 ca       	lddpc	r10,800130e4 <scheduleXNL_ACK+0xc8>
80013078:	94 1a       	ld.sh	r10,r10[0x2]
8001307a:	b0 1a       	st.h	r8[0x2],r10
	      = theXNL_Ctrlr.XNL_DeviceAddress;

	//Turn around Transaction ID.
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.transactionID
8001307c:	f6 c8 ff f4 	sub	r8,r11,-12
80013080:	92 69       	ld.sh	r9,r9[0xc]
80013082:	b0 09       	st.h	r8[0x0],r9
	      = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.transactionID;

	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.payloadLength
80013084:	30 09       	mov	r9,0
80013086:	b0 19       	st.h	r8[0x2],r9
          = 0;

	//fill in checksums.
	sumTxInstance(theInstance);
80013088:	0e 9c       	mov	r12,r7
8001308a:	f0 1f 00 18 	mcall	800130e8 <scheduleXNL_ACK+0xcc>

	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
8001308e:	49 88       	lddpc	r8,800130ec <scheduleXNL_ACK+0xd0>
80013090:	70 78       	ld.w	r8,r8[0x1c]
80013092:	58 48       	cp.w	r8,4
80013094:	c1 61       	brne	800130c0 <scheduleXNL_ACK+0xa4>
		//Immediate transmission allowed.
		TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
80013096:	49 18       	lddpc	r8,800130d8 <scheduleXNL_ACK+0xbc>
80013098:	ee 09 15 03 	lsl	r9,r7,0x3
8001309c:	2f f9       	sub	r9,-1
8001309e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
800130a2:	f4 ca f0 60 	sub	r10,r10,-4000
800130a6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	    TxInstancePool[theInstance].behavior = OWNEDXCMPACKPROTO;
800130aa:	ee 09 15 05 	lsl	r9,r7,0x5
800130ae:	30 1a       	mov	r10,1
800130b0:	ea 1a a0 01 	orh	r10,0xa001
800130b4:	f0 09 09 0a 	st.w	r8[r9],r10
		txSchedule.NextWaitingIndex = theInstance;
800130b8:	48 d8       	lddpc	r8,800130ec <scheduleXNL_ACK+0xd0>
800130ba:	91 77       	st.w	r8[0x1c],r7
800130bc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
	}else{
		//Leave RetryTime at current time.
		TxInstancePool[theInstance].behavior = TXXCMPACKPROTO;
800130c0:	a5 77       	lsl	r7,0x5
800130c2:	30 29       	mov	r9,2
800130c4:	ea 19 20 01 	orh	r9,0x2001
800130c8:	48 48       	lddpc	r8,800130d8 <scheduleXNL_ACK+0xbc>
800130ca:	f0 07 09 09 	st.w	r8[r7],r9
800130ce:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800130d2:	00 00       	add	r0,r0
800130d4:	80 01       	ld.sh	r1,r0[0x0]
800130d6:	28 14       	sub	r4,-127
800130d8:	00 00       	add	r0,r0
800130da:	38 64       	mov	r4,-122
800130dc:	00 00       	add	r0,r0
800130de:	39 04       	mov	r4,-112
800130e0:	00 00       	add	r0,r0
800130e2:	38 38       	mov	r8,-125
800130e4:	00 00       	add	r0,r0
800130e6:	38 50       	mov	r0,-123
800130e8:	80 01       	ld.sh	r1,r0[0x0]
800130ea:	2a 84       	sub	r4,-88
800130ec:	00 00       	add	r0,r0
800130ee:	49 24       	lddpc	r4,80013134 <sendOpcode_Not_Supported+0x14>

800130f0 <newFlag>:
}

U16 newFlag(void)
{
	U16 flag;
	flag = (theXNL_Ctrlr.XNL_3BitRollover + 1) & 0x0007;
800130f0:	48 48       	lddpc	r8,80013100 <newFlag+0x10>
800130f2:	90 4c       	ld.sh	r12,r8[0x8]
800130f4:	2f fc       	sub	r12,-1
800130f6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
	theXNL_Ctrlr.XNL_3BitRollover = flag;
800130fa:	b0 4c       	st.h	r8[0x8],r12
	return flag;
}
800130fc:	5e fc       	retal	r12
800130fe:	00 00       	add	r0,r0
80013100:	00 00       	add	r0,r0
80013102:	38 50       	mov	r0,-123

80013104 <newTransID>:

U16 newTransID(void)
{
	U16 TransID;
	TransID = ((theXNL_Ctrlr.XNL_TransactionIDBase & 0x00FF) + 1) & 0x00FF;
80013104:	48 68       	lddpc	r8,8001311c <newTransID+0x18>
	TransID |= theXNL_Ctrlr.XNL_TransactionIDBase & 0xFF00;
80013106:	90 39       	ld.sh	r9,r8[0x6]
80013108:	f9 d9 c0 08 	bfextu	r12,r9,0x0,0x8
8001310c:	2f fc       	sub	r12,-1
8001310e:	e2 19 ff 00 	andl	r9,0xff00,COH
80013112:	12 4c       	or	r12,r9
80013114:	5c 8c       	casts.h	r12
	theXNL_Ctrlr.XNL_TransactionIDBase = TransID;
80013116:	b0 3c       	st.h	r8[0x6],r12
	return TransID;
}
80013118:	5e fc       	retal	r12
8001311a:	00 00       	add	r0,r0
8001311c:	00 00       	add	r0,r0
8001311e:	38 50       	mov	r0,-123

80013120 <sendOpcode_Not_Supported>:

void sendOpcode_Not_Supported(U16 XCMPopcode)
{
80013120:	eb cd 40 fc 	pushm	r2-r7,lr
80013124:	18 92       	mov	r2,r12
	U8 theInstance;

	theInstance = reserveTxInstance(DEVINITSTS_BLOCK_COUNT);
80013126:	30 1c       	mov	r12,1
80013128:	f0 1f 00 32 	mcall	800131f0 <sendOpcode_Not_Supported+0xd0>
	if (theInstance == TXINSTANCESBOUND){ //Are we able to schedule?
8001312c:	30 48       	mov	r8,4
8001312e:	f0 0c 18 00 	cp.b	r12,r8
80013132:	c5 d0       	breq	800131ec <sendOpcode_Not_Supported+0xcc>
		return;
	}

	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
80013134:	18 96       	mov	r6,r12
80013136:	4b 04       	lddpc	r4,800131f4 <sendOpcode_Not_Supported+0xd4>
80013138:	f8 05 15 02 	lsl	r5,r12,0x2
8001313c:	2f f5       	sub	r5,-1
8001313e:	e8 05 03 33 	ld.w	r3,r4[r5<<0x3]
80013142:	4a e7       	lddpc	r7,800131f8 <sendOpcode_Not_Supported+0xd8>
80013144:	e6 08 15 08 	lsl	r8,r3,0x8
80013148:	2f 08       	sub	r8,-16
8001314a:	ee 08 00 08 	add	r8,r7,r8
8001314e:	ea 12 ff ff 	orh	r2,0xffff
80013152:	e8 12 80 00 	orl	r2,0x8000
80013156:	b0 02       	st.h	r8[0x0],r2
		                                                  .XNL
		                                                  .theXNLpayload
		                                                  .ContentXNL_DATA_MSG
		                                                  .XCNPopcode
		                                               = XCMPopcode | 0x8000;
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
80013158:	30 39       	mov	r9,3
8001315a:	b0 a9       	st.b	r8[0x2],r9
		                                                  .theXNLpayload
		                                                  .ContentXNL_DATA_MSG
		                                                  .u8[0]
		                                               = XCMPRESULT_NOTSUPPORTED;

	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theMAC_Header.phy_control = 0x4011;
8001315c:	e6 08 15 08 	lsl	r8,r3,0x8
80013160:	e0 69 40 11 	mov	r9,16401
80013164:	ee 08 0a 09 	st.h	r7[r8],r9
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode = XNL_DATA_MSG;
80013168:	a7 63       	lsl	r3,0x6
8001316a:	2f f3       	sub	r3,-1
8001316c:	30 b8       	mov	r8,11
8001316e:	ee 03 0a 28 	st.h	r7[r3<<0x2],r8
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.flags = 0x0100 | newFlag();
80013172:	f0 1f 00 23 	mcall	800131fc <sendOpcode_Not_Supported+0xdc>
80013176:	ee 03 00 23 	add	r3,r7,r3<<0x2
8001317a:	a9 ac       	sbr	r12,0x8
8001317c:	a6 1c       	st.h	r3[0x2],r12
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.source;
8001317e:	e8 05 03 39 	ld.w	r9,r4[r5<<0x3]
80013182:	4a 08       	lddpc	r8,80013200 <sendOpcode_Not_Supported+0xe0>
80013184:	70 18       	ld.w	r8,r8[0x4]
80013186:	f2 0a 15 05 	lsl	r10,r9,0x5
8001318a:	2f fa       	sub	r10,-1
8001318c:	90 5b       	ld.sh	r11,r8[0xa]
8001318e:	ee 0a 0a 3b 	st.h	r7[r10<<0x3],r11
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.source = theXNL_Ctrlr.XNL_DeviceAddress;
80013192:	ee 0a 00 3a 	add	r10,r7,r10<<0x3
80013196:	49 cb       	lddpc	r11,80013204 <sendOpcode_Not_Supported+0xe4>
80013198:	96 1b       	ld.sh	r11,r11[0x2]
8001319a:	b4 1b       	st.h	r10[0x2],r11
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.transactionID = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.transactionID;
8001319c:	a9 69       	lsl	r9,0x8
8001319e:	12 07       	add	r7,r9
800131a0:	2f 47       	sub	r7,-12
800131a2:	90 68       	ld.sh	r8,r8[0xc]
800131a4:	ae 08       	st.h	r7[0x0],r8
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.payloadLength = 0x0003;
800131a6:	30 38       	mov	r8,3
800131a8:	ae 18       	st.h	r7[0x2],r8
	sumTxInstance(theInstance);
800131aa:	0c 9c       	mov	r12,r6
800131ac:	f0 1f 00 17 	mcall	80013208 <sendOpcode_Not_Supported+0xe8>

	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
800131b0:	49 78       	lddpc	r8,8001320c <sendOpcode_Not_Supported+0xec>
800131b2:	70 78       	ld.w	r8,r8[0x1c]
800131b4:	58 48       	cp.w	r8,4
800131b6:	c1 51       	brne	800131e0 <sendOpcode_Not_Supported+0xc0>
			//Immediate transmission allowed.
			TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
800131b8:	ec 09 15 03 	lsl	r9,r6,0x3
800131bc:	2f f9       	sub	r9,-1
800131be:	e8 09 03 2a 	ld.w	r10,r4[r9<<0x2]
800131c2:	f4 ca f0 60 	sub	r10,r10,-4000
800131c6:	e8 09 09 2a 	st.w	r4[r9<<0x2],r10
			TxInstancePool[theInstance].behavior = OWNEDXCNPMSGPROTO;
800131ca:	ec 09 15 05 	lsl	r9,r6,0x5
800131ce:	30 5a       	mov	r10,5
800131d0:	ea 1a 80 01 	orh	r10,0x8001
800131d4:	e8 09 09 0a 	st.w	r4[r9],r10
			txSchedule.NextWaitingIndex = theInstance;
800131d8:	48 d8       	lddpc	r8,8001320c <sendOpcode_Not_Supported+0xec>
800131da:	91 76       	st.w	r8[0x1c],r6
800131dc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}else{
			//Leave RetryTime at current time.
			TxInstancePool[theInstance].behavior = TXXCMPMSGPROTO;
800131e0:	a5 76       	lsl	r6,0x5
800131e2:	e0 79 00 06 	mov	r9,65542
800131e6:	48 48       	lddpc	r8,800131f4 <sendOpcode_Not_Supported+0xd4>
800131e8:	f0 06 09 09 	st.w	r8[r6],r9
800131ec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800131f0:	80 01       	ld.sh	r1,r0[0x0]
800131f2:	28 14       	sub	r4,-127
800131f4:	00 00       	add	r0,r0
800131f6:	38 64       	mov	r4,-122
800131f8:	00 00       	add	r0,r0
800131fa:	39 04       	mov	r4,-112
800131fc:	80 01       	ld.sh	r1,r0[0x0]
800131fe:	30 f0       	mov	r0,15
80013200:	00 00       	add	r0,r0
80013202:	38 38       	mov	r8,-125
80013204:	00 00       	add	r0,r0
80013206:	38 50       	mov	r0,-123
80013208:	80 01       	ld.sh	r1,r0[0x0]
8001320a:	2a 84       	sub	r4,-88
8001320c:	00 00       	add	r0,r0
8001320e:	49 24       	lddpc	r4,80013254 <sendTONECTRLREQ+0x44>

80013210 <sendTONECTRLREQ>:
	}
}

Bool sendTONECTRLREQ(void)
{
80013210:	eb cd 40 f8 	pushm	r3-r7,lr
	U8 theInstance;
	U8 i;

	theInstance = reserveTxInstance(TONECTRLREQ_BLOCK_COUNT);
80013214:	30 1c       	mov	r12,1
80013216:	f0 1f 00 39 	mcall	800132f8 <sendTONECTRLREQ+0xe8>
	if (theInstance == TXINSTANCESBOUND){ //Are we able to schedule?
8001321a:	30 48       	mov	r8,4
8001321c:	f0 0c 18 00 	cp.b	r12,r8
80013220:	c0 31       	brne	80013226 <sendTONECTRLREQ+0x16>
80013222:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
			return FALSE;
	}

	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
80013226:	18 96       	mov	r6,r12
80013228:	f8 09 15 02 	lsl	r9,r12,0x2
8001322c:	2f f9       	sub	r9,-1
8001322e:	4b 48       	lddpc	r8,800132fc <sendTONECTRLREQ+0xec>
80013230:	f0 09 03 35 	ld.w	r5,r8[r9<<0x3]
80013234:	ea 09 15 08 	lsl	r9,r5,0x8
80013238:	2f 09       	sub	r9,-16
8001323a:	4b 28       	lddpc	r8,80013300 <sendTONECTRLREQ+0xf0>
8001323c:	f0 09 00 09 	add	r9,r8,r9
80013240:	e0 68 04 09 	mov	r8,1033
80013244:	12 b8       	st.h	r9++,r8
80013246:	4b 08       	lddpc	r8,80013304 <sendTONECTRLREQ+0xf4>
			//Leave RetryTime at current time.
			TxInstancePool[theInstance].behavior = TXXCMPMSGPROTO;
	}
}

Bool sendTONECTRLREQ(void)
80013248:	f0 cb ff f7 	sub	r11,r8,-9
		                                              .XNL
		                                              .theXNLpayload
		                                              .ContentXNL_DATA_MSG
		                                              .XCNPopcode = XCMP_TONECTRLREQ;
	for (i=0; i<DEVINITSTS_BYTE_COUNT; i++){
	     TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
8001324c:	11 3a       	ld.ub	r10,r8++
8001324e:	12 ca       	st.b	r9++,r10
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
		                                              .XNL
		                                              .theXNLpayload
		                                              .ContentXNL_DATA_MSG
		                                              .XCNPopcode = XCMP_TONECTRLREQ;
	for (i=0; i<DEVINITSTS_BYTE_COUNT; i++){
80013250:	16 38       	cp.w	r8,r11
80013252:	cf d1       	brne	8001324c <sendTONECTRLREQ+0x3c>
			                                          .theXNLpayload
			                                          .ContentXNL_DATA_MSG
			                                          .u8[i] = TONECTRLREQPROTO[i];
	}

	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theMAC_Header.phy_control = 0x4018;
80013254:	4a b7       	lddpc	r7,80013300 <sendTONECTRLREQ+0xf0>
80013256:	ea 08 15 08 	lsl	r8,r5,0x8
8001325a:	e0 69 40 18 	mov	r9,16408
8001325e:	ee 08 0a 09 	st.h	r7[r8],r9
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode = XNL_DATA_MSG;
80013262:	a7 65       	lsl	r5,0x6
80013264:	2f f5       	sub	r5,-1
80013266:	30 b8       	mov	r8,11
80013268:	ee 05 0a 28 	st.h	r7[r5<<0x2],r8
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.flags = 0x0100 | newFlag();
8001326c:	f0 1f 00 27 	mcall	80013308 <sendTONECTRLREQ+0xf8>
80013270:	ee 05 00 25 	add	r5,r7,r5<<0x2
80013274:	a9 ac       	sbr	r12,0x8
80013276:	aa 1c       	st.h	r5[0x2],r12
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination = theXNL_Ctrlr.XNL_MasterAddress;
80013278:	4a 13       	lddpc	r3,800132fc <sendTONECTRLREQ+0xec>
8001327a:	ec 04 15 02 	lsl	r4,r6,0x2
8001327e:	2f f4       	sub	r4,-1
80013280:	e6 04 03 35 	ld.w	r5,r3[r4<<0x3]
80013284:	ea 09 15 05 	lsl	r9,r5,0x5
80013288:	2f f9       	sub	r9,-1
8001328a:	4a 18       	lddpc	r8,8001330c <sendTONECTRLREQ+0xfc>
8001328c:	90 0a       	ld.sh	r10,r8[0x0]
8001328e:	ee 09 0a 3a 	st.h	r7[r9<<0x3],r10
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.source = theXNL_Ctrlr.XNL_DeviceAddress;
80013292:	ee 09 00 39 	add	r9,r7,r9<<0x3
80013296:	90 18       	ld.sh	r8,r8[0x2]
80013298:	b2 18       	st.h	r9[0x2],r8
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.transactionID = newTransID();
8001329a:	f0 1f 00 1e 	mcall	80013310 <sendTONECTRLREQ+0x100>
8001329e:	a9 65       	lsl	r5,0x8
800132a0:	ee 05 00 05 	add	r5,r7,r5
800132a4:	aa 6c       	st.h	r5[0xc],r12
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.payloadLength = 0x000A;
800132a6:	e6 04 03 38 	ld.w	r8,r3[r4<<0x3]
800132aa:	a9 68       	lsl	r8,0x8
800132ac:	10 07       	add	r7,r8
800132ae:	30 a8       	mov	r8,10
800132b0:	ae 78       	st.h	r7[0xe],r8
	sumTxInstance(theInstance);
800132b2:	0c 9c       	mov	r12,r6
800132b4:	f0 1f 00 18 	mcall	80013314 <sendTONECTRLREQ+0x104>

	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
800132b8:	49 88       	lddpc	r8,80013318 <sendTONECTRLREQ+0x108>
800132ba:	70 78       	ld.w	r8,r8[0x1c]
800132bc:	58 48       	cp.w	r8,4
800132be:	c1 51       	brne	800132e8 <sendTONECTRLREQ+0xd8>
			//Immediate transmission allowed.
			TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
800132c0:	ec 09 15 03 	lsl	r9,r6,0x3
800132c4:	2f f9       	sub	r9,-1
800132c6:	e6 09 03 2a 	ld.w	r10,r3[r9<<0x2]
800132ca:	f4 ca f0 60 	sub	r10,r10,-4000
800132ce:	e6 09 09 2a 	st.w	r3[r9<<0x2],r10
		    TxInstancePool[theInstance].behavior = OWNEDXCNPMSGPROTO;
800132d2:	ec 09 15 05 	lsl	r9,r6,0x5
800132d6:	30 5a       	mov	r10,5
800132d8:	ea 1a 80 01 	orh	r10,0x8001
800132dc:	e6 09 09 0a 	st.w	r3[r9],r10
			txSchedule.NextWaitingIndex = theInstance;
800132e0:	48 e8       	lddpc	r8,80013318 <sendTONECTRLREQ+0x108>
800132e2:	91 76       	st.w	r8[0x1c],r6
800132e4:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
	}else{
			//Leave RetryTime at current time.
			TxInstancePool[theInstance].behavior = TXXCMPMSGPROTO;
800132e8:	a5 76       	lsl	r6,0x5
800132ea:	e0 79 00 06 	mov	r9,65542
800132ee:	48 48       	lddpc	r8,800132fc <sendTONECTRLREQ+0xec>
800132f0:	f0 06 09 09 	st.w	r8[r6],r9
800132f4:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
800132f8:	80 01       	ld.sh	r1,r0[0x0]
800132fa:	28 14       	sub	r4,-127
800132fc:	00 00       	add	r0,r0
800132fe:	38 64       	mov	r4,-122
80013300:	00 00       	add	r0,r0
80013302:	39 04       	mov	r4,-112
80013304:	80 01       	ld.sh	r1,r0[0x0]
80013306:	3e 48       	mov	r8,-28
80013308:	80 01       	ld.sh	r1,r0[0x0]
8001330a:	30 f0       	mov	r0,15
8001330c:	00 00       	add	r0,r0
8001330e:	38 50       	mov	r0,-123
80013310:	80 01       	ld.sh	r1,r0[0x0]
80013312:	31 04       	mov	r4,16
80013314:	80 01       	ld.sh	r1,r0[0x0]
80013316:	2a 84       	sub	r4,-88
80013318:	00 00       	add	r0,r0
8001331a:	49 24       	lddpc	r4,80013360 <sendDEVINITSTS+0x44>

8001331c <sendDEVINITSTS>:
	return TRUE;
}


void sendDEVINITSTS(void)
{
8001331c:	eb cd 40 fc 	pushm	r2-r7,lr
	U8 theInstance;
	U8 i;

	theInstance = reserveTxInstance(DEVINITSTS_BLOCK_COUNT);
80013320:	30 1c       	mov	r12,1
80013322:	f0 1f 00 38 	mcall	80013400 <sendDEVINITSTS+0xe4>
	if (theInstance == TXINSTANCESBOUND){ //Are we able to schedule?
80013326:	30 48       	mov	r8,4
80013328:	f0 0c 18 00 	cp.b	r12,r8
8001332c:	c6 70       	breq	800133fa <sendDEVINITSTS+0xde>
		return;
	}
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
8001332e:	18 96       	mov	r6,r12
80013330:	f8 09 15 02 	lsl	r9,r12,0x2
80013334:	2f f9       	sub	r9,-1
80013336:	4b 48       	lddpc	r8,80013404 <sendDEVINITSTS+0xe8>
80013338:	f0 09 03 34 	ld.w	r4,r8[r9<<0x3]
8001333c:	e8 09 15 08 	lsl	r9,r4,0x8
80013340:	2f 09       	sub	r9,-16
80013342:	4b 28       	lddpc	r8,80013408 <sendDEVINITSTS+0xec>
80013344:	f0 09 00 09 	add	r9,r8,r9
80013348:	fe 78 b4 00 	mov	r8,-19456
8001334c:	12 b8       	st.h	r9++,r8
8001334e:	4b 08       	lddpc	r8,8001340c <sendDEVINITSTS+0xf0>
	}
	return TRUE;
}


void sendDEVINITSTS(void)
80013350:	f0 cb ff f7 	sub	r11,r8,-9
	                                                  .XNL
	                                                  .theXNLpayload
	                                                  .ContentXNL_DATA_MSG
	                                                  .XCNPopcode = XCMP_DEVINITSTS;
	for (i=0; i<DEVINITSTS_BYTE_COUNT; i++){
		TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
80013354:	11 3a       	ld.ub	r10,r8++
80013356:	12 ca       	st.b	r9++,r10
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]]
	                                                  .XNL
	                                                  .theXNLpayload
	                                                  .ContentXNL_DATA_MSG
	                                                  .XCNPopcode = XCMP_DEVINITSTS;
	for (i=0; i<DEVINITSTS_BYTE_COUNT; i++){
80013358:	16 38       	cp.w	r8,r11
8001335a:	cf d1       	brne	80013354 <sendDEVINITSTS+0x38>
		                                              .XNL
		                                              .theXNLpayload
		                                              .ContentXNL_DATA_MSG
		                                              .u8[i] = DEVINITSTSPROTO[i];
	}
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theMAC_Header.phy_control = 0x4019;
8001335c:	4a b7       	lddpc	r7,80013408 <sendDEVINITSTS+0xec>
8001335e:	e8 08 15 08 	lsl	r8,r4,0x8
80013362:	e0 69 40 19 	mov	r9,16409
80013366:	ee 08 0a 09 	st.h	r7[r8],r9
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.opcode = XNL_DATA_MSG;
8001336a:	a7 64       	lsl	r4,0x6
8001336c:	2f f4       	sub	r4,-1
8001336e:	30 b5       	mov	r5,11
80013370:	ee 04 0a 25 	st.h	r7[r4<<0x2],r5
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.flags = 0x0100 | newFlag();
80013374:	f0 1f 00 27 	mcall	80013410 <sendDEVINITSTS+0xf4>
80013378:	ee 04 00 24 	add	r4,r7,r4<<0x2
8001337c:	a9 ac       	sbr	r12,0x8
8001337e:	a8 1c       	st.h	r4[0x2],r12
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.destination = 0x0000;
80013380:	4a 12       	lddpc	r2,80013404 <sendDEVINITSTS+0xe8>
80013382:	ec 03 15 02 	lsl	r3,r6,0x2
80013386:	2f f3       	sub	r3,-1
80013388:	e4 03 03 34 	ld.w	r4,r2[r3<<0x3]
8001338c:	e8 08 15 05 	lsl	r8,r4,0x5
80013390:	2f f8       	sub	r8,-1
80013392:	30 09       	mov	r9,0
80013394:	ee 08 0a 39 	st.h	r7[r8<<0x3],r9
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.source = theXNL_Ctrlr.XNL_DeviceAddress;
80013398:	ee 08 00 38 	add	r8,r7,r8<<0x3
8001339c:	49 e9       	lddpc	r9,80013414 <sendDEVINITSTS+0xf8>
8001339e:	92 19       	ld.sh	r9,r9[0x2]
800133a0:	b0 19       	st.h	r8[0x2],r9
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.transactionID = newTransID();
800133a2:	f0 1f 00 1e 	mcall	80013418 <sendDEVINITSTS+0xfc>
800133a6:	a9 64       	lsl	r4,0x8
800133a8:	ee 04 00 04 	add	r4,r7,r4
800133ac:	a8 6c       	st.h	r4[0xc],r12
	TxBufferPool[TxInstancePool[theInstance].BlockIndex[0]].XNL.theXNL_Header.payloadLength = 0x000B;
800133ae:	e4 03 03 38 	ld.w	r8,r2[r3<<0x3]
800133b2:	a9 68       	lsl	r8,0x8
800133b4:	10 07       	add	r7,r8
800133b6:	ae 75       	st.h	r7[0xe],r5
	sumTxInstance(theInstance);
800133b8:	0c 9c       	mov	r12,r6
800133ba:	f0 1f 00 19 	mcall	8001341c <sendDEVINITSTS+0x100>

	if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){
800133be:	49 98       	lddpc	r8,80013420 <sendDEVINITSTS+0x104>
800133c0:	70 78       	ld.w	r8,r8[0x1c]
800133c2:	58 48       	cp.w	r8,4
800133c4:	c1 51       	brne	800133ee <sendDEVINITSTS+0xd2>
			//Immediate transmission allowed.
			TxInstancePool[theInstance].RetryTime += STANDARDTIMEOUT;
800133c6:	ec 09 15 03 	lsl	r9,r6,0x3
800133ca:	2f f9       	sub	r9,-1
800133cc:	e4 09 03 2a 	ld.w	r10,r2[r9<<0x2]
800133d0:	f4 ca f0 60 	sub	r10,r10,-4000
800133d4:	e4 09 09 2a 	st.w	r2[r9<<0x2],r10
		    TxInstancePool[theInstance].behavior = OWNEDXCNPMSGPROTO;
800133d8:	ec 09 15 05 	lsl	r9,r6,0x5
800133dc:	30 5a       	mov	r10,5
800133de:	ea 1a 80 01 	orh	r10,0x8001
800133e2:	e4 09 09 0a 	st.w	r2[r9],r10
			txSchedule.NextWaitingIndex = theInstance;
800133e6:	48 f8       	lddpc	r8,80013420 <sendDEVINITSTS+0x104>
800133e8:	91 76       	st.w	r8[0x1c],r6
800133ea:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	}else{
			//Leave RetryTime at current time.
			TxInstancePool[theInstance].behavior = TXXCMPMSGPROTO;
800133ee:	a5 76       	lsl	r6,0x5
800133f0:	e0 79 00 06 	mov	r9,65542
800133f4:	48 48       	lddpc	r8,80013404 <sendDEVINITSTS+0xe8>
800133f6:	f0 06 09 09 	st.w	r8[r6],r9
800133fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800133fe:	00 00       	add	r0,r0
80013400:	80 01       	ld.sh	r1,r0[0x0]
80013402:	28 14       	sub	r4,-127
80013404:	00 00       	add	r0,r0
80013406:	38 64       	mov	r4,-122
80013408:	00 00       	add	r0,r0
8001340a:	39 04       	mov	r4,-112
8001340c:	80 01       	ld.sh	r1,r0[0x0]
8001340e:	3e 3c       	mov	r12,-29
80013410:	80 01       	ld.sh	r1,r0[0x0]
80013412:	30 f0       	mov	r0,15
80013414:	00 00       	add	r0,r0
80013416:	38 50       	mov	r0,-123
80013418:	80 01       	ld.sh	r1,r0[0x0]
8001341a:	31 04       	mov	r4,16
8001341c:	80 01       	ld.sh	r1,r0[0x0]
8001341e:	2a 84       	sub	r4,-88
80013420:	00 00       	add	r0,r0
80013422:	49 24       	lddpc	r4,80013468 <processXNL_DATA_MSG+0x14>

80013424 <processXNL_DATA_MSG_ACK>:
	}
}

void processXNL_DATA_MSG_ACK(void)
{
80013424:	d4 01       	pushm	lr
	U16 DestinationAddress;
	U16 TransactionID;

	DestinationAddress = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.destination;
80013426:	48 88       	lddpc	r8,80013444 <processXNL_DATA_MSG_ACK+0x20>
80013428:	70 18       	ld.w	r8,r8[0x4]
8001342a:	48 89       	lddpc	r9,80013448 <processXNL_DATA_MSG_ACK+0x24>
8001342c:	92 1a       	ld.sh	r10,r9[0x2]
8001342e:	90 49       	ld.sh	r9,r8[0x8]
80013430:	f2 0a 19 00 	cp.h	r10,r9
80013434:	c0 61       	brne	80013440 <processXNL_DATA_MSG_ACK+0x1c>
	if ((theXNL_Ctrlr.XNL_DeviceAddress) == DestinationAddress){
		//The ack is for me.
		TransactionID = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.transactionID;
		//if (instanceIndex >= TXINSTANCESBOUND) return;handled in releaseTxInstance.
		releaseTxInstance(findTxInstance_byTransID(TransactionID));
80013436:	90 ec       	ld.uh	r12,r8[0xc]
80013438:	f0 1f 00 05 	mcall	8001344c <processXNL_DATA_MSG_ACK+0x28>
8001343c:	f0 1f 00 05 	mcall	80013450 <processXNL_DATA_MSG_ACK+0x2c>
80013440:	d8 02       	popm	pc
80013442:	00 00       	add	r0,r0
80013444:	00 00       	add	r0,r0
80013446:	38 38       	mov	r8,-125
80013448:	00 00       	add	r0,r0
8001344a:	38 50       	mov	r0,-123
8001344c:	80 01       	ld.sh	r1,r0[0x0]
8001344e:	29 34       	sub	r4,-109
80013450:	80 01       	ld.sh	r1,r0[0x0]
80013452:	29 ac       	sub	r12,-102

80013454 <processXNL_DATA_MSG>:
	}
}

void processXNL_DATA_MSG(void)
{
80013454:	d4 01       	pushm	lr
	U16 DestinationAddress;
	U16 XCMPopcode;
	U16 temp;

	DestinationAddress = (theRxCirCtrlr.pRxTemplate)->theXNL_Header.destination;
80013456:	4a c8       	lddpc	r8,80013504 <processXNL_DATA_MSG+0xb0>
80013458:	70 18       	ld.w	r8,r8[0x4]
8001345a:	90 48       	ld.sh	r8,r8[0x8]
	if ((0x000000 == DestinationAddress)
8001345c:	58 08       	cp.w	r8,0
8001345e:	c0 60       	breq	8001346a <processXNL_DATA_MSG+0x16>
80013460:	4a a9       	lddpc	r9,80013508 <processXNL_DATA_MSG+0xb4>
80013462:	92 19       	ld.sh	r9,r9[0x2]
80013464:	f0 09 19 00 	cp.h	r9,r8
80013468:	c4 c1       	brne	80013500 <processXNL_DATA_MSG+0xac>
		|| (theXNL_Ctrlr.XNL_DeviceAddress == DestinationAddress)){
        //The message is for me.
		if (scheduleXNL_ACK()){ //Try to schedule ACK.
8001346a:	f0 1f 00 29 	mcall	8001350c <processXNL_DATA_MSG+0xb8>
8001346e:	c4 90       	breq	80013500 <processXNL_DATA_MSG+0xac>
		//If cannot schedule ACK, just leave without processing message;
		//XNL will retry again, and hopefully our Tx resources will then be free.
		//If ACK has been scheduled. It most likely is already	owned
		//by the transmitter, but possibly is waiting in Queue with immediate
	    //timeout.
		    XCMPopcode = (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.XCNPopcode;
80013470:	4a 58       	lddpc	r8,80013504 <processXNL_DATA_MSG+0xb0>
80013472:	70 18       	ld.w	r8,r8[0x4]
80013474:	f1 0c 00 10 	ld.sh	r12,r8[16]
            switch (XCMPopcode){
80013478:	fe 79 b4 00 	mov	r9,-19456
8001347c:	f2 0c 19 00 	cp.h	r12,r9
80013480:	c0 70       	breq	8001348e <processXNL_DATA_MSG+0x3a>
80013482:	fe 79 b4 28 	mov	r9,-19416
80013486:	f2 0c 19 00 	cp.h	r12,r9
8001348a:	c3 41       	brne	800134f2 <processXNL_DATA_MSG+0x9e>
8001348c:	c1 88       	rjmp	800134bc <processXNL_DATA_MSG+0x68>
            case XCMP_DEVINITSTS:
            	if ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.u8[4] == DIC){
8001348e:	f1 38 00 16 	ld.ub	r8,r8[22]
80013492:	30 19       	mov	r9,1
80013494:	f2 08 18 00 	cp.b	r8,r9
80013498:	c0 61       	brne	800134a4 <processXNL_DATA_MSG+0x50>
            		bunchofrandomstatusflags |= DIC;  //Need do nothing else.
8001349a:	49 e8       	lddpc	r8,80013510 <processXNL_DATA_MSG+0xbc>
8001349c:	70 09       	ld.w	r9,r8[0x0]
8001349e:	a1 a9       	sbr	r9,0x0
800134a0:	91 09       	st.w	r8[0x0],r9
800134a2:	d8 02       	popm	pc
            	}else if((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.u8[4] != 0x02){
800134a4:	30 29       	mov	r9,2
800134a6:	f2 08 18 00 	cp.b	r8,r9
800134aa:	c2 b0       	breq	80013500 <processXNL_DATA_MSG+0xac>
					bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800134ac:	49 98       	lddpc	r8,80013510 <processXNL_DATA_MSG+0xbc>
800134ae:	70 09       	ld.w	r9,r8[0x0]
800134b0:	e0 19 ff fc 	andl	r9,0xfffc
800134b4:	91 09       	st.w	r8[0x0],r9
					sendDEVINITSTS();			
800134b6:	f0 1f 00 18 	mcall	80013514 <processXNL_DATA_MSG+0xc0>
800134ba:	d8 02       	popm	pc
            		//bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
            		//sendDEVINITSTS();
            	}
            	break;
            case XCMP_DEVMGMTBCST:
            	temp  = (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.u8[1] << 8;
800134bc:	f1 2a 00 13 	ld.sb	r10,r8[19]
            	temp |= (theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.u8[2];
800134c0:	f1 39 00 14 	ld.ub	r9,r8[20]
800134c4:	f3 ea 10 89 	or	r9,r9,r10<<0x8
800134c8:	49 0a       	lddpc	r10,80013508 <processXNL_DATA_MSG+0xb4>
800134ca:	94 2a       	ld.sh	r10,r10[0x4]
800134cc:	f2 0a 19 00 	cp.h	r10,r9
800134d0:	c1 81       	brne	80013500 <processXNL_DATA_MSG+0xac>
            	if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress){
            		if ((theRxCirCtrlr.pRxTemplate)->theXNL_Payload.ContentXNL_DATA_MSG.u8[0] == 0x01){
800134d2:	f1 39 00 12 	ld.ub	r9,r8[18]
800134d6:	30 18       	mov	r8,1
800134d8:	f0 09 18 00 	cp.b	r9,r8
800134dc:	c0 61       	brne	800134e8 <processXNL_DATA_MSG+0x94>
            			//Enable Option Board
            			bunchofrandomstatusflags |= 0x00000002;
800134de:	48 d8       	lddpc	r8,80013510 <processXNL_DATA_MSG+0xbc>
800134e0:	70 09       	ld.w	r9,r8[0x0]
800134e2:	a1 b9       	sbr	r9,0x1
800134e4:	91 09       	st.w	r8[0x0],r9
800134e6:	d8 02       	popm	pc
            		}else{
            			//Disable Option Board.
            			bunchofrandomstatusflags &= 0xFFFFFFFD;
800134e8:	48 a8       	lddpc	r8,80013510 <processXNL_DATA_MSG+0xbc>
800134ea:	70 09       	ld.w	r9,r8[0x0]
800134ec:	a1 d9       	cbr	r9,0x1
800134ee:	91 09       	st.w	r8[0x0],r9
800134f0:	d8 02       	popm	pc
            		}
            	}
            	break;
            default:
            	if ((XCMPopcode & XCMP_MTMask) == XCMP_requestMT){
800134f2:	5c 7c       	castu.h	r12
800134f4:	18 98       	mov	r8,r12
800134f6:	e2 18 f0 00 	andl	r8,0xf000,COH
800134fa:	c0 31       	brne	80013500 <processXNL_DATA_MSG+0xac>
            	   sendOpcode_Not_Supported(XCMPopcode);
800134fc:	f0 1f 00 07 	mcall	80013518 <processXNL_DATA_MSG+0xc4>
80013500:	d8 02       	popm	pc
80013502:	00 00       	add	r0,r0
80013504:	00 00       	add	r0,r0
80013506:	38 38       	mov	r8,-125
80013508:	00 00       	add	r0,r0
8001350a:	38 50       	mov	r0,-123
8001350c:	80 01       	ld.sh	r1,r0[0x0]
8001350e:	30 1c       	mov	r12,1
80013510:	00 00       	add	r0,r0
80013512:	28 20       	sub	r0,-126
80013514:	80 01       	ld.sh	r1,r0[0x0]
80013516:	33 1c       	mov	r12,49
80013518:	80 01       	ld.sh	r1,r0[0x0]
8001351a:	31 20       	mov	r0,18

8001351c <process_XNL>:
	}
}


void process_XNL(void)
{
8001351c:	d4 01       	pushm	lr
  U32 temp;
  U8 SomeInstance;

  garbageCollect();
8001351e:	f0 1f 00 58 	mcall	8001367c <process_XNL+0x160>

  theXNL_Ctrlr.isIncomingMessage = FALSE;
80013522:	30 09       	mov	r9,0
80013524:	4d 78       	lddpc	r8,80013680 <process_XNL+0x164>
80013526:	f1 69 00 10 	st.b	r8[16],r9
  if (theRxCirCtrlr.RxXNL_ProcessWaitingIndex != theRxCirCtrlr.RxXNL_IsFillingMessageIndex) {
8001352a:	4d 78       	lddpc	r8,80013684 <process_XNL+0x168>
8001352c:	f1 09 00 14 	ld.sh	r9,r8[20]
80013530:	f1 08 00 10 	ld.sh	r8,r8[16]
80013534:	f2 08 19 00 	cp.h	r8,r9
80013538:	c1 10       	breq	8001355a <process_XNL+0x3e>

	  //Align XNL Template with message in circular buffer.
	  theRxCirCtrlr.pRxTemplate = (RxTemplate*)(&(theRxCirBuffer.theRxFragment[theRxCirCtrlr.RxXNL_ProcessWaitingIndex]));
8001353a:	a9 69       	lsl	r9,0x8
8001353c:	4d 38       	lddpc	r8,80013688 <process_XNL+0x16c>
8001353e:	10 09       	add	r9,r8
80013540:	4d 18       	lddpc	r8,80013684 <process_XNL+0x168>
80013542:	91 19       	st.w	r8[0x4],r9
      if ( 0 == (((theRxCirCtrlr.pRxTemplate)->theMAC_Header.phy_control) & 0x0F00)){
80013544:	92 88       	ld.uh	r8,r9[0x0]
80013546:	e2 18 0f 00 	andl	r8,0xf00,COH
8001354a:	c0 61       	brne	80013556 <process_XNL+0x3a>
    	  theXNL_Ctrlr.isIncomingMessage = TRUE;
8001354c:	30 19       	mov	r9,1
8001354e:	4c d8       	lddpc	r8,80013680 <process_XNL+0x164>
80013550:	f1 69 00 10 	st.b	r8[16],r9
80013554:	c0 38       	rjmp	8001355a <process_XNL+0x3e>
      }else{ //This simple implementation throws away multiple fragments.
    	  depleteAProcessedMessage();
80013556:	f0 1f 00 4e 	mcall	8001368c <process_XNL+0x170>
      }
  }

  switch (theXNL_Ctrlr.XNL_State) {
8001355a:	4c a8       	lddpc	r8,80013680 <process_XNL+0x164>
8001355c:	70 38       	ld.w	r8,r8[0xc]
8001355e:	58 18       	cp.w	r8,1
80013560:	c1 a0       	breq	80013594 <process_XNL+0x78>
80013562:	c0 63       	brcs	8001356e <process_XNL+0x52>
80013564:	58 28       	cp.w	r8,2
80013566:	c2 a0       	breq	800135ba <process_XNL+0x9e>
80013568:	58 38       	cp.w	r8,3
8001356a:	c5 a1       	brne	8001361e <process_XNL+0x102>
8001356c:	c3 f8       	rjmp	800135ea <process_XNL+0xce>
  case XNL_UNCONNECTEDWAITINGSTATUS:
    if   (theXNL_Ctrlr.isIncomingMessage) {
8001356e:	4c 58       	lddpc	r8,80013680 <process_XNL+0x164>
80013570:	f1 39 00 10 	ld.ub	r9,r8[16]
80013574:	30 08       	mov	r8,0
80013576:	f0 09 18 00 	cp.b	r9,r8
8001357a:	c5 20       	breq	8001361e <process_XNL+0x102>
      if ( XNL_MASTER_STATUS_BRDCST ==
    	  (theRxCirCtrlr.pRxTemplate)->theXNL_Header.opcode ){
8001357c:	4c 28       	lddpc	r8,80013684 <process_XNL+0x168>
8001357e:	70 18       	ld.w	r8,r8[0x4]
80013580:	90 29       	ld.sh	r9,r8[0x4]
80013582:	30 28       	mov	r8,2
80013584:	f0 09 19 00 	cp.h	r9,r8
80013588:	c0 31       	brne	8001358e <process_XNL+0x72>
	    processXNL_MASTER_STATUS_BRDCST();
8001358a:	f0 1f 00 42 	mcall	80013690 <process_XNL+0x174>
      }
	      depleteAProcessedMessage(); //This state depletes everything.
8001358e:	f0 1f 00 40 	mcall	8001368c <process_XNL+0x170>
80013592:	c4 68       	rjmp	8001361e <process_XNL+0x102>
    }
    break;


  case XNL_UNCONNECTEDWAITINGAUTHKEY:
	  if   (theXNL_Ctrlr.isIncomingMessage) {
80013594:	4b b8       	lddpc	r8,80013680 <process_XNL+0x164>
80013596:	f1 39 00 10 	ld.ub	r9,r8[16]
8001359a:	30 08       	mov	r8,0
8001359c:	f0 09 18 00 	cp.b	r9,r8
800135a0:	c3 f0       	breq	8001361e <process_XNL+0x102>
		  if (XNL_DEVICE_AUTH_KEY_REPLY ==
			  (theRxCirCtrlr.pRxTemplate)->theXNL_Header.opcode ){
800135a2:	4b 98       	lddpc	r8,80013684 <process_XNL+0x168>
800135a4:	70 18       	ld.w	r8,r8[0x4]
800135a6:	90 29       	ld.sh	r9,r8[0x4]
800135a8:	30 58       	mov	r8,5
800135aa:	f0 09 19 00 	cp.h	r9,r8
800135ae:	c0 31       	brne	800135b4 <process_XNL+0x98>
			  processXNL_DEVICE_AUTH_KEY_REPLY();
800135b0:	f0 1f 00 39 	mcall	80013694 <process_XNL+0x178>
		  }
	      depleteAProcessedMessage(); //It is possible we could receive another XNL_MASTER_STATUS_BRDCST
800135b4:	f0 1f 00 36 	mcall	8001368c <process_XNL+0x170>
800135b8:	c3 38       	rjmp	8001361e <process_XNL+0x102>
	  break;


  case XNL_UNCONNECTEDWAITINGDEVICECONN:

	  AVR32_GPIO.port[1].ovrc  =  0x00000008;
800135ba:	30 89       	mov	r9,8
800135bc:	fe 78 10 00 	mov	r8,-61440
800135c0:	f1 49 01 58 	st.w	r8[344],r9
  	  if   (theXNL_Ctrlr.isIncomingMessage) {
800135c4:	4a f8       	lddpc	r8,80013680 <process_XNL+0x164>
800135c6:	f1 39 00 10 	ld.ub	r9,r8[16]
800135ca:	30 08       	mov	r8,0
800135cc:	f0 09 18 00 	cp.b	r9,r8
800135d0:	c2 70       	breq	8001361e <process_XNL+0x102>
  		  if (XNL_DEVICE_CONN_REPLY ==
  			  (theRxCirCtrlr.pRxTemplate)->theXNL_Header.opcode ){
800135d2:	4a d8       	lddpc	r8,80013684 <process_XNL+0x168>
800135d4:	70 18       	ld.w	r8,r8[0x4]
800135d6:	90 29       	ld.sh	r9,r8[0x4]
800135d8:	30 78       	mov	r8,7
800135da:	f0 09 19 00 	cp.h	r9,r8
800135de:	c0 31       	brne	800135e4 <process_XNL+0xc8>
  			  processXNL_DEVICE_CONN_REPLY();
800135e0:	f0 1f 00 2e 	mcall	80013698 <process_XNL+0x17c>
  		  }
  	      depleteAProcessedMessage(); //It is possible we could receive another XNL_MASTER_STATUS_BRDCST
800135e4:	f0 1f 00 2a 	mcall	8001368c <process_XNL+0x170>
800135e8:	c1 b8       	rjmp	8001361e <process_XNL+0x102>
  	  break;

  case XNL_CONNECTED:

	  
  	  if   (theXNL_Ctrlr.isIncomingMessage) {
800135ea:	4a 68       	lddpc	r8,80013680 <process_XNL+0x164>
800135ec:	f1 39 00 10 	ld.ub	r9,r8[16]
800135f0:	30 08       	mov	r8,0
800135f2:	f0 09 18 00 	cp.b	r9,r8
800135f6:	c1 40       	breq	8001361e <process_XNL+0x102>
  		  switch ((theRxCirCtrlr.pRxTemplate)->theXNL_Header.opcode){
800135f8:	4a 38       	lddpc	r8,80013684 <process_XNL+0x168>
800135fa:	70 18       	ld.w	r8,r8[0x4]
800135fc:	90 28       	ld.sh	r8,r8[0x4]
800135fe:	30 b9       	mov	r9,11
80013600:	f2 08 19 00 	cp.h	r8,r9
80013604:	c0 60       	breq	80013610 <process_XNL+0xf4>
80013606:	30 c9       	mov	r9,12
80013608:	f2 08 19 00 	cp.h	r8,r9
8001360c:	c0 71       	brne	8001361a <process_XNL+0xfe>
8001360e:	c0 48       	rjmp	80013616 <process_XNL+0xfa>
  		  case XNL_DEVICE_SYSMAP_BRDCST:

  			  break;
  		  case XNL_DATA_MSG:
  			  processXNL_DATA_MSG();
80013610:	f0 1f 00 23 	mcall	8001369c <process_XNL+0x180>
  			  break;
80013614:	c0 38       	rjmp	8001361a <process_XNL+0xfe>
  		  case XNL_DATA_MSG_ACK:
  			  processXNL_DATA_MSG_ACK();
80013616:	f0 1f 00 23 	mcall	800136a0 <process_XNL+0x184>
  			  break;
		  }//End of switch on XNL Header Opcode
  	      depleteAProcessedMessage();
8001361a:	f0 1f 00 1d 	mcall	8001368c <process_XNL+0x170>

    break;
  } //End of switch on XNL_State.

  //Need to search for active instances with timeouts.
  SomeInstance = findTxInstance_byTimeout();
8001361e:	f0 1f 00 22 	mcall	800136a4 <process_XNL+0x188>
  if (SomeInstance != TXINSTANCESBOUND){//Some Instance needs a retry.
80013622:	30 48       	mov	r8,4
80013624:	f0 0c 18 00 	cp.b	r12,r8
80013628:	c2 80       	breq	80013678 <process_XNL+0x15c>
	  if (txSchedule.NextWaitingIndex == TXINSTANCESBOUND){//Scheduling allowed
8001362a:	4a 08       	lddpc	r8,800136a8 <process_XNL+0x18c>
8001362c:	70 78       	ld.w	r8,r8[0x1c]
8001362e:	58 48       	cp.w	r8,4
80013630:	c2 41       	brne	80013678 <process_XNL+0x15c>
	      //Formally, shouldn't retry something that's stuck in transmitter.
		  //Should in general never fail this test.
		  if (((TxInstancePool[SomeInstance].behavior) & FGOWNSBEHAVIOR) == 0x00000000){
80013632:	f8 08 15 05 	lsl	r8,r12,0x5
80013636:	49 e9       	lddpc	r9,800136ac <process_XNL+0x190>
80013638:	f2 08 03 08 	ld.w	r8,r9[r8]
8001363c:	58 08       	cp.w	r8,0
8001363e:	c1 d5       	brlt	80013678 <process_XNL+0x15c>
			  temp = ((TxInstancePool[SomeInstance].behavior) & TXINSTANCERETRYMASK) - 1;
80013640:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80013644:	20 19       	sub	r9,1
			  if (temp == 0){ //All retries exhausted.
80013646:	c0 41       	brne	8001364e <process_XNL+0x132>
				  //In general case should maybe signal some error.
				  releaseTxInstance(SomeInstance);
80013648:	f0 1f 00 1a 	mcall	800136b0 <process_XNL+0x194>
8001364c:	d8 02       	popm	pc
			  }else{
				  TxInstancePool[SomeInstance].behavior &= 0x3FFF0000; //Clear owned, sent, old count.
				  TxInstancePool[SomeInstance].behavior |= temp;       //Update new count;
				  TxInstancePool[SomeInstance].behavior |= FGOWNSBEHAVIOR;
8001364e:	49 8a       	lddpc	r10,800136ac <process_XNL+0x190>
80013650:	f8 0b 15 05 	lsl	r11,r12,0x5
80013654:	e6 18 3f ff 	andh	r8,0x3fff,COH
80013658:	bf b8       	sbr	r8,0x1f
8001365a:	f1 e9 10 09 	or	r9,r8,r9
8001365e:	f4 0b 09 09 	st.w	r10[r11],r9
				  TxInstancePool[SomeInstance].RetryTime = theRxCirCtrlr.RxLinkCount
80013662:	f8 08 15 03 	lsl	r8,r12,0x3
80013666:	2f f8       	sub	r8,-1
80013668:	48 79       	lddpc	r9,80013684 <process_XNL+0x168>
8001366a:	72 09       	ld.w	r9,r9[0x0]
8001366c:	f2 c9 f0 60 	sub	r9,r9,-4000
80013670:	f4 08 09 29 	st.w	r10[r8<<0x2],r9
		  								          + STANDARDTIMEOUT;
				  txSchedule.NextWaitingIndex = SomeInstance;
80013674:	48 d8       	lddpc	r8,800136a8 <process_XNL+0x18c>
80013676:	91 7c       	st.w	r8[0x1c],r12
80013678:	d8 02       	popm	pc
8001367a:	00 00       	add	r0,r0
8001367c:	80 01       	ld.sh	r1,r0[0x0]
8001367e:	2a 54       	sub	r4,-91
80013680:	00 00       	add	r0,r0
80013682:	38 50       	mov	r0,-123
80013684:	00 00       	add	r0,r0
80013686:	38 38       	mov	r8,-125
80013688:	00 00       	add	r0,r0
8001368a:	28 38       	sub	r8,-125
8001368c:	80 01       	ld.sh	r1,r0[0x0]
8001368e:	2b 18       	sub	r8,-79
80013690:	80 01       	ld.sh	r1,r0[0x0]
80013692:	2c a4       	sub	r4,-54
80013694:	80 01       	ld.sh	r1,r0[0x0]
80013696:	2d 8c       	sub	r12,-40
80013698:	80 01       	ld.sh	r1,r0[0x0]
8001369a:	2f 00       	sub	r0,-16
8001369c:	80 01       	ld.sh	r1,r0[0x0]
8001369e:	34 54       	mov	r4,69
800136a0:	80 01       	ld.sh	r1,r0[0x0]
800136a2:	34 24       	mov	r4,66
800136a4:	80 01       	ld.sh	r1,r0[0x0]
800136a6:	29 70       	sub	r0,-105
800136a8:	00 00       	add	r0,r0
800136aa:	49 24       	lddpc	r4,800136f0 <local_start_pll0+0x3c>
800136ac:	00 00       	add	r0,r0
800136ae:	38 64       	mov	r4,-122
800136b0:	80 01       	ld.sh	r1,r0[0x0]
800136b2:	29 ac       	sub	r12,-102

800136b4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	               (&AVR32_PM)->oscctrl0 = 0x00000307;
800136b4:	fe 78 0c 00 	mov	r8,-62464
800136b8:	e0 69 03 07 	mov	r9,775
800136bc:	91 a9       	st.w	r8[0x28],r9
	               (&AVR32_PM)->mcctrl   = 0x00000004;
800136be:	30 49       	mov	r9,4
800136c0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	               while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800136c2:	71 59       	ld.w	r9,r8[0x54]
800136c4:	e2 19 00 80 	andl	r9,0x80,COH
800136c8:	cf d0       	breq	800136c2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	               (&AVR32_PM)->mcctrl   = 0x00000005;
800136ca:	fe 78 0c 00 	mov	r8,-62464
800136ce:	30 59       	mov	r9,5
800136d0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	               (&AVR32_PM)->pll[0] = 0x1007010D;
800136d2:	e0 69 01 0d 	mov	r9,269
800136d6:	ea 19 10 07 	orh	r9,0x1007
800136da:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	              while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800136dc:	71 59       	ld.w	r9,r8[0x54]
800136de:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800136e2:	cf d0       	breq	800136dc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	              (&AVR32_PM)->cksel = 0x00800000;
800136e4:	fe 78 0c 00 	mov	r8,-62464
800136e8:	fc 19 00 80 	movh	r9,0x80
800136ec:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	              AVR32_FLASHC.fcr = 0x00000040;
800136ee:	34 0a       	mov	r10,64
800136f0:	fe 69 14 00 	mov	r9,-125952
800136f4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	              (&AVR32_PM)->mcctrl   = 0x00000006;
800136f6:	30 69       	mov	r9,6
800136f8:	91 09       	st.w	r8[0x0],r9


	              AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800136fa:	30 19       	mov	r9,1
800136fc:	fe 68 10 00 	mov	r8,-126976
80013700:	91 19       	st.w	r8[0x4],r9
}
80013702:	5e fc       	retal	r12

80013704 <local_start_SSC>:
//Before using the SSC transmitter, the PIO controller must be configured to dedicate the SSC
//transmitter I/O lines to the SSC peripheral mode. [23.6.1]
// Assign GPIO to SSC.
	//gpio_enable_module
	//     gpio_enable_module_pin
	    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80013704:	fe 78 10 00 	mov	r8,-61440
80013708:	e0 69 0d c0 	mov	r9,3520
8001370c:	f1 49 01 18 	st.w	r8[280],r9
	    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80013710:	f1 49 01 28 	st.w	r8[296],r9
	    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80013714:	f1 49 01 08 	st.w	r8[264],r9

   //Software reset SSC
  (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80013718:	fe 78 34 00 	mov	r8,-52224
8001371c:	e0 69 80 00 	mov	r9,32768
80013720:	91 09       	st.w	r8[0x0],r9

  (&AVR32_SSC)->cmr = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;           //For Slave
80013722:	30 09       	mov	r9,0
80013724:	91 19       	st.w	r8[0x4],r9


  //For Slave
  (&AVR32_SSC)->tcmr =
80013726:	e0 69 04 21 	mov	r9,1057
8001372a:	ea 19 3f 20 	orh	r9,0x3f20
8001372e:	91 69       	st.w	r8[0x18],r9
                32                                      << AVR32_SSC_TCMR_STTDLY_OFFSET |
                63                                      << AVR32_SSC_TCMR_PERIOD_OFFSET;


  //For Slave
  (&AVR32_SSC)->tfmr =
80013730:	e0 69 02 9f 	mov	r9,671
80013734:	ea 19 01 00 	orh	r9,0x100
80013738:	91 79       	st.w	r8[0x1c],r9
                  AVR32_SSC_TFMR_FSOS_INPUT_ONLY        << AVR32_SSC_TFMR_FSOS_OFFSET   |
                  0                                     << AVR32_SSC_TFMR_FSDEN_OFFSET  |
                  1                                     << AVR32_SSC_TFMR_FSEDGE_OFFSET;

  //For Slave
  (&AVR32_SSC)->rcmr =
8001373a:	e0 6a 04 02 	mov	r10,1026
8001373e:	ea 1a 3f 20 	orh	r10,0x3f20
80013742:	91 4a       	st.w	r8[0x10],r10
                0                                       << AVR32_SSC_RCMR_STOP_OFFSET   |
                32                                      << AVR32_SSC_RCMR_STTDLY_OFFSET |
                63                                      << AVR32_SSC_RCMR_PERIOD_OFFSET;

  //For Slave
  (&AVR32_SSC)->rfmr =
80013744:	91 59       	st.w	r8[0x14],r9
                  0                                     << AVR32_SSC_RFMR_FSLEN_OFFSET  |
                  AVR32_SSC_RFMR_FSOS_INPUT_ONLY        << AVR32_SSC_RFMR_FSOS_OFFSET   |
                  1                                     << AVR32_SSC_RFMR_FSEDGE_OFFSET;


}
80013746:	5e fc       	retal	r12

80013748 <local_start_PDC>:

void local_start_PDC(void)
{
80013748:	d4 01       	pushm	lr
	  BufferIndex = 1;
8001374a:	30 19       	mov	r9,1
8001374c:	49 78       	lddpc	r8,800137a8 <local_start_PDC+0x60>
8001374e:	b0 89       	st.b	r8[0x0],r9

	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
80013750:	fe 78 00 00 	mov	r8,-65536
80013754:	30 7b       	mov	r11,7
80013756:	91 9b       	st.w	r8[0x24],r11
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;                             //Dummy read?
80013758:	70 b9       	ld.w	r9,r8[0x2c]
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = (U32)(&RxBuffer[0].theXNL_Channel.word);
8001375a:	49 59       	lddpc	r9,800137ac <local_start_PDC+0x64>
8001375c:	f2 ca ff fc 	sub	r10,r9,-4
80013760:	91 0a       	st.w	r8[0x0],r10
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80013762:	30 3a       	mov	r10,3
80013764:	91 2a       	st.w	r8[0x8],r10
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_RX;
80013766:	30 1c       	mov	r12,1
80013768:	91 1c       	st.w	r8[0x4],r12
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = (U32)(&RxBuffer[1].theXNL_Channel.word);
8001376a:	2e c9       	sub	r9,-20
8001376c:	91 39       	st.w	r8[0xc],r9
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8001376e:	91 4a       	st.w	r8[0x10],r10
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80013770:	30 2c       	mov	r12,2
80013772:	91 6c       	st.w	r8[0x18],r12


	  TxBuffer[0].theXNL_Channel.word = XNL_IDLE;
80013774:	48 f9       	lddpc	r9,800137b0 <local_start_PDC+0x68>
80013776:	e0 68 5a 5a 	mov	r8,23130
8001377a:	ea 18 ab cd 	orh	r8,0xabcd
8001377e:	93 18       	st.w	r9[0x4],r8
	  TxBuffer[0].thePayload_Channel.word[0] = PAYLOADIDLE0;
80013780:	93 28       	st.w	r9[0x8],r8
	  TxBuffer[0].thePayload_Channel.word[1] = PAYLOADIDLE1;
80013782:	30 0e       	mov	lr,0
80013784:	93 3e       	st.w	r9[0xc],lr
	  TxBuffer[1].theXNL_Channel.word = XNL_IDLE;
80013786:	93 58       	st.w	r9[0x14],r8
	  TxBuffer[1].thePayload_Channel.word[0] = PAYLOADIDLE0;
80013788:	93 68       	st.w	r9[0x18],r8
	  TxBuffer[1].thePayload_Channel.word[1] = PAYLOADIDLE1;
8001378a:	93 7e       	st.w	r9[0x1c],lr

	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK; //Atomic!
8001378c:	fe 78 00 40 	mov	r8,-65472
80013790:	91 9b       	st.w	r8[0x24],r11
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;                                                                    //Dummy read?
80013792:	70 be       	ld.w	lr,r8[0x2c]
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = (U32)(&TxBuffer[0].theXNL_Channel.word);
80013794:	f2 ce ff fc 	sub	lr,r9,-4
80013798:	91 0e       	st.w	r8[0x0],lr
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8001379a:	91 2a       	st.w	r8[0x8],r10
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8001379c:	91 1b       	st.w	r8[0x4],r11
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = (U32)(&TxBuffer[1].theXNL_Channel.word);
8001379e:	2e c9       	sub	r9,-20
800137a0:	91 39       	st.w	r8[0xc],r9
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800137a2:	91 4a       	st.w	r8[0x10],r10
	  (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800137a4:	91 6c       	st.w	r8[0x18],r12
}
800137a6:	d8 02       	popm	pc
800137a8:	00 00       	add	r0,r0
800137aa:	00 1c       	sub	r12,r0
800137ac:	00 00       	add	r0,r0
800137ae:	38 e4       	mov	r4,-114
800137b0:	00 00       	add	r0,r0
800137b2:	49 04       	lddpc	r4,800137f0 <Delay>

800137b4 <local_start_timer>:
//

void local_start_timer(void)
{
    //Route CLK to Timer
      AVR32_GPIO.port[0].pmr0s = 0x00100000;
800137b4:	fe 78 10 00 	mov	r8,-61440
800137b8:	fc 19 00 10 	movh	r9,0x10
800137bc:	91 59       	st.w	r8[0x14],r9
      AVR32_GPIO.port[0].pmr1c = 0x00100000;
800137be:	91 a9       	st.w	r8[0x28],r9
      AVR32_GPIO.port[0].gperc = 0x00100000;
800137c0:	91 29       	st.w	r8[0x8],r9
      //Route FS and Tri-State to Timer.
      AVR32_GPIO.port[1].pmr0c = 0x00000003;
800137c2:	30 39       	mov	r9,3
800137c4:	f1 49 01 18 	st.w	r8[280],r9
      AVR32_GPIO.port[1].pmr1c = 0x00000003;
800137c8:	f1 49 01 28 	st.w	r8[296],r9
      AVR32_GPIO.port[1].gperc = 0x00000003;
800137cc:	f1 49 01 08 	st.w	r8[264],r9

      (&AVR32_TC)->bmr = 4;
800137d0:	fe 78 38 00 	mov	r8,-51200
800137d4:	30 49       	mov	r9,4
800137d6:	f1 49 00 c4 	st.w	r8[196],r9
      (&AVR32_TC)->channel[0].cmr =
800137da:	e0 69 91 0d 	mov	r9,37133
800137de:	ea 19 00 52 	orh	r9,0x52
800137e2:	91 19       	st.w	r8[0x4],r9
                                        1                          << AVR32_TC_CLKI_OFFSET     |
                                        AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



      (&AVR32_TC)->channel[0].ra = 32;
800137e4:	32 09       	mov	r9,32
800137e6:	91 59       	st.w	r8[0x14],r9
      (&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800137e8:	30 59       	mov	r9,5
800137ea:	91 09       	st.w	r8[0x0],r9
}
800137ec:	5e fc       	retal	r12
800137ee:	d7 03       	nop

800137f0 <Delay>:
   -1,                      //Group 17 USB
};


void Delay(unsigned long  Delay) 
{   
800137f0:	eb cd 40 c0 	pushm	r6-r7,lr
800137f4:	18 96       	mov	r6,r12
800137f6:	30 07       	mov	r7,0
    unsigned long elasp=0;
    do 
    {
          elasp+=1;
800137f8:	2f f7       	sub	r7,-1
		  process_XNL();
800137fa:	f0 1f 00 04 	mcall	80013808 <Delay+0x18>
    }
    while (elasp< Delay);
800137fe:	0c 37       	cp.w	r7,r6
80013800:	cf c3       	brcs	800137f8 <Delay+0x8>
 
}
80013802:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80013806:	00 00       	add	r0,r0
80013808:	80 01       	ld.sh	r1,r0[0x0]
8001380a:	35 1c       	mov	r12,81

8001380c <Delay_ms>:
   
void Delay_ms(unsigned long  Delay_ms) 
{   
8001380c:	eb cd 40 e0 	pushm	r5-r7,lr
80013810:	18 96       	mov	r6,r12
80013812:	30 07       	mov	r7,0
    unsigned long elasp_ms=0;
    do 
    {
		Delay(6000); 
80013814:	e0 65 17 70 	mov	r5,6000
80013818:	0a 9c       	mov	r12,r5
8001381a:	f0 1f 00 04 	mcall	80013828 <Delay_ms+0x1c>

		  elasp_ms+=1;
8001381e:	2f f7       	sub	r7,-1
    }
    while (elasp_ms< Delay_ms);
80013820:	0c 37       	cp.w	r7,r6
80013822:	cf b3       	brcs	80013818 <Delay_ms+0xc>
 
}
80013824:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80013828:	80 01       	ld.sh	r1,r0[0x0]
8001382a:	37 f0       	mov	r0,127

8001382c <pdca_int_handler>:
        //Reserved for Double-Tap Interrupt.
  }

__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
8001382c:	d4 21       	pushm	r4-r7,lr
	intStartCount = Get_system_register(AVR32_COUNT);
8001382e:	e1 b8 00 42 	mfsr	r8,0x108
80013832:	4a 45       	lddpc	r5,800138c0 <pdca_int_handler+0x94>
80013834:	8b 08       	st.w	r5[0x0],r8
	//TxBuffer and RxBuffer terminates the Option Card SSC Physical Layer.
	BufferIndex ^= 0x01; //Toggle Index.
80013836:	4a 47       	lddpc	r7,800138c4 <pdca_int_handler+0x98>
80013838:	0f 88       	ld.ub	r8,r7[0x0]
8001383a:	ec 18 00 01 	eorl	r8,0x1
8001383e:	ae 88       	st.b	r7[0x0],r8
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = (U32)(&TxBuffer[BufferIndex].theXNL_Channel.word);
80013840:	0f 89       	ld.ub	r9,r7[0x0]
80013842:	a5 69       	lsl	r9,0x4
80013844:	2f c9       	sub	r9,-4
80013846:	4a 16       	lddpc	r6,800138c8 <pdca_int_handler+0x9c>
80013848:	0c 09       	add	r9,r6
8001384a:	fe 78 00 40 	mov	r8,-65472
8001384e:	91 39       	st.w	r8[0xc],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;  //Three words xfered each DMA.
80013850:	30 3a       	mov	r10,3
80013852:	91 4a       	st.w	r8[0x10],r10


	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = (U32)(&RxBuffer[BufferIndex].theXNL_Channel.word);
80013854:	0f 8b       	ld.ub	r11,r7[0x0]
80013856:	a5 6b       	lsl	r11,0x4
80013858:	2f cb       	sub	r11,-4
8001385a:	49 d9       	lddpc	r9,800138cc <pdca_int_handler+0xa0>
8001385c:	12 0b       	add	r11,r9
8001385e:	fe 78 00 00 	mov	r8,-65536
80013862:	91 3b       	st.w	r8[0xc],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;  //Three words xfered each DMA.
80013864:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80013866:	70 b8       	ld.w	r8,r8[0x2c]

	theRxCirCtrlr.RxLinkCount += 1;
80013868:	49 a8       	lddpc	r8,800138d0 <pdca_int_handler+0xa4>
8001386a:	70 0a       	ld.w	r10,r8[0x0]
8001386c:	2f fa       	sub	r10,-1
8001386e:	91 0a       	st.w	r8[0x0],r10

	XNL_PhyRx(RxBuffer[BufferIndex].theXNL_Channel.word);
80013870:	0f 88       	ld.ub	r8,r7[0x0]
80013872:	a3 68       	lsl	r8,0x2
80013874:	2f f8       	sub	r8,-1
80013876:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
8001387a:	f0 1f 00 17 	mcall	800138d4 <pdca_int_handler+0xa8>
	TxBuffer[BufferIndex].theXNL_Channel.word = XNL_PhyTx();
8001387e:	0f 84       	ld.ub	r4,r7[0x0]
80013880:	f0 1f 00 16 	mcall	800138d8 <pdca_int_handler+0xac>
80013884:	a3 64       	lsl	r4,0x2
80013886:	2f f4       	sub	r4,-1
80013888:	ec 04 09 2c 	st.w	r6[r4<<0x2],r12
	RxPhyMedia();
8001388c:	f0 1f 00 14 	mcall	800138dc <pdca_int_handler+0xb0>


    //Dummy code to Idle Tx Media.
    TxBuffer[BufferIndex].thePayload_Channel.word[0] = PAYLOADIDLE0;
80013890:	0f 88       	ld.ub	r8,r7[0x0]
80013892:	a1 78       	lsl	r8,0x1
80013894:	2f f8       	sub	r8,-1
80013896:	e0 69 5a 5a 	mov	r9,23130
8001389a:	ea 19 ab cd 	orh	r9,0xabcd
8001389e:	ec 08 09 39 	st.w	r6[r8<<0x3],r9
    TxBuffer[BufferIndex].thePayload_Channel.word[1] = PAYLOADIDLE1;
800138a2:	0f 88       	ld.ub	r8,r7[0x0]
800138a4:	a5 68       	lsl	r8,0x4
800138a6:	10 06       	add	r6,r8
800138a8:	2f 46       	sub	r6,-12
800138aa:	30 08       	mov	r8,0
800138ac:	8d 08       	st.w	r6[0x0],r8
    intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
800138ae:	e1 b9 00 42 	mfsr	r9,0x108
800138b2:	6a 08       	ld.w	r8,r5[0x0]
800138b4:	10 19       	sub	r9,r8
800138b6:	48 b8       	lddpc	r8,800138e0 <pdca_int_handler+0xb4>
800138b8:	91 09       	st.w	r8[0x0],r9

}//End of pdca_int_handler.
800138ba:	d4 22       	popm	r4-r7,lr
800138bc:	d6 03       	rete
800138be:	00 00       	add	r0,r0
800138c0:	00 00       	add	r0,r0
800138c2:	28 34       	sub	r4,-125
800138c4:	00 00       	add	r0,r0
800138c6:	00 1c       	sub	r12,r0
800138c8:	00 00       	add	r0,r0
800138ca:	49 04       	lddpc	r4,80013908 <main+0x24>
800138cc:	00 00       	add	r0,r0
800138ce:	38 e4       	mov	r4,-114
800138d0:	00 00       	add	r0,r0
800138d2:	38 38       	mov	r8,-125
800138d4:	80 01       	ld.sh	r1,r0[0x0]
800138d6:	20 80       	sub	r0,8
800138d8:	80 01       	ld.sh	r1,r0[0x0]
800138da:	22 24       	sub	r4,34
800138dc:	80 01       	ld.sh	r1,r0[0x0]
800138de:	23 a0       	sub	r0,58
800138e0:	00 00       	add	r0,r0
800138e2:	00 08       	add	r8,r0

800138e4 <main>:
      (&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
}


int main(void)
{
800138e4:	d4 31       	pushm	r0-r7,lr
800138e6:	20 1d       	sub	sp,4
  while(TRUE){
  //	Delay_ms(6000);
    Disable_global_interrupt();
    DontPanic = TRUE;
800138e8:	4a d5       	lddpc	r5,8001399c <main+0xb8>
800138ea:	30 12       	mov	r2,1
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
   AVR32_GPIO.port[1].ovrs  =  0x00000009;  //Value will be high.
800138ec:	fe 77 10 00 	mov	r7,-61440
800138f0:	30 96       	mov	r6,9

        //       
	     //       Delay_ms(6000);
	      //        Delay_ms(6000);

    bunchofrandomstatusflags = 0x00000000;
800138f2:	4a c1       	lddpc	r1,800139a0 <main+0xbc>
800138f4:	30 03       	mov	r3,0
800138f6:	50 03       	stdsp	sp[0x0],r3
    //accelerometer_init();


    //Set up PB03 to watch FS.
    //Waits for radio to start making FSYNC.
      AVR32_GPIO.port[1].oderc = 0x00000002;
800138f8:	30 24       	mov	r4,2

int main(void)
{
  while(TRUE){
  //	Delay_ms(6000);
    Disable_global_interrupt();
800138fa:	d3 03       	ssrf	0x10
    DontPanic = TRUE;
800138fc:	aa 82       	st.b	r5[0x0],r2
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
   AVR32_GPIO.port[1].ovrs  =  0x00000009;  //Value will be high.
800138fe:	ef 46 01 54 	st.w	r7[340],r6
   AVR32_GPIO.port[1].gpers =  0x00000009;  //Enable as GPIO.
80013902:	ef 46 01 04 	st.w	r7[260],r6
   AVR32_GPIO.port[1].oders =  0x00000009;  //Output Driver will be Enabled.
80013906:	ef 46 01 44 	st.w	r7[324],r6

        //       
	     //       Delay_ms(6000);
	      //        Delay_ms(6000);

    bunchofrandomstatusflags = 0x00000000;
8001390a:	40 08       	lddsp	r8,sp[0x0]
8001390c:	83 08       	st.w	r1[0x0],r8

	devflag=0;
8001390e:	4a 68       	lddpc	r8,800139a4 <main+0xc0>
80013910:	b0 83       	st.b	r8[0x0],r3

    
    local_start_pll0();
80013912:	f0 1f 00 26 	mcall	800139a8 <main+0xc4>
    my_init_interrupts();
80013916:	f0 1f 00 26 	mcall	800139ac <main+0xc8>
    //accelerometer_init();


    //Set up PB03 to watch FS.
    //Waits for radio to start making FSYNC.
      AVR32_GPIO.port[1].oderc = 0x00000002;
8001391a:	ef 44 01 48 	st.w	r7[328],r4
      AVR32_GPIO.port[1].gpers = 0x00000002;
8001391e:	ef 44 01 04 	st.w	r7[260],r4
      while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80013922:	ee f8 01 60 	ld.w	r8,r7[352]
80013926:	e2 18 00 02 	andl	r8,0x2,COH
8001392a:	cf c0       	breq	80013922 <main+0x3e>
      while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8001392c:	ee f8 01 60 	ld.w	r8,r7[352]
80013930:	e2 18 00 02 	andl	r8,0x2,COH
80013934:	cf c1       	brne	8001392c <main+0x48>

	 // 	delay(3000);
	//delay(3000);

    local_start_SSC();
80013936:	f0 1f 00 1f 	mcall	800139b0 <main+0xcc>
    local_start_PDC();
8001393a:	f0 1f 00 1f 	mcall	800139b4 <main+0xd0>

    initXNL();
8001393e:	f0 1f 00 1f 	mcall	800139b8 <main+0xd4>

    //Start the SSC Physical Layer.
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80013942:	fe 79 00 00 	mov	r9,-65536
80013946:	30 18       	mov	r8,1
80013948:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8001394a:	fe 7a 00 40 	mov	r10,-65472
8001394e:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80013950:	e0 6b 01 01 	mov	r11,257
80013954:	fe 7a 34 00 	mov	r10,-52224
80013958:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
8001395a:	93 88       	st.w	r9[0x20],r8

    Enable_global_interrupt();
8001395c:	d5 03       	csrf	0x10

    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8001395e:	ee f8 01 60 	ld.w	r8,r7[352]
80013962:	e2 18 00 02 	andl	r8,0x2,COH
80013966:	cf c0       	breq	8001395e <main+0x7a>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80013968:	ee f8 01 60 	ld.w	r8,r7[352]
8001396c:	e2 18 00 02 	andl	r8,0x2,COH
80013970:	cf c1       	brne	80013968 <main+0x84>
    local_start_timer();
80013972:	f0 1f 00 13 	mcall	800139bc <main+0xd8>

	U8 i;
    while(DontPanic){

    Delay_ms(100);
80013976:	36 40       	mov	r0,100
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
    local_start_timer();

	U8 i;
    while(DontPanic){
80013978:	c0 e8       	rjmp	80013994 <main+0xb0>

    Delay_ms(100);
8001397a:	00 9c       	mov	r12,r0
8001397c:	f0 1f 00 11 	mcall	800139c0 <main+0xdc>
	
	//sendTONECTRLREQ();
	//if (0x00000003 == (bunchofrandomstatusflags & 0x00000003)){
	if (0x00000001 == (bunchofrandomstatusflags & 0x00000003)){
80013980:	62 08       	ld.w	r8,r1[0x0]
		for (i=6;i<10; i++)
		{;
		}
	}
	
	if (0x00000003 == (bunchofrandomstatusflags & 0x00000003)){
80013982:	62 08       	ld.w	r8,r1[0x0]
80013984:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80013988:	58 38       	cp.w	r8,3
8001398a:	c0 51       	brne	80013994 <main+0xb0>
		sendTONECTRLREQ();
8001398c:	f0 1f 00 0e 	mcall	800139c4 <main+0xe0>
		sendTONECTRLREQ();
80013990:	f0 1f 00 0d 	mcall	800139c4 <main+0xe0>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
    local_start_timer();

	U8 i;
    while(DontPanic){
80013994:	0b 88       	ld.ub	r8,r5[0x0]
80013996:	58 08       	cp.w	r8,0
80013998:	cb 10       	breq	800138fa <main+0x16>
8001399a:	cf 0b       	rjmp	8001397a <main+0x96>
8001399c:	00 00       	add	r0,r0
8001399e:	49 44       	lddpc	r4,800139ec <idata_load_loop_end+0x2>
800139a0:	00 00       	add	r0,r0
800139a2:	28 20       	sub	r0,-126
800139a4:	00 00       	add	r0,r0
800139a6:	00 1d       	sub	sp,r0
800139a8:	80 01       	ld.sh	r1,r0[0x0]
800139aa:	36 b4       	mov	r4,107
800139ac:	80 01       	ld.sh	r1,r0[0x0]
800139ae:	20 14       	sub	r4,1
800139b0:	80 01       	ld.sh	r1,r0[0x0]
800139b2:	37 04       	mov	r4,112
800139b4:	80 01       	ld.sh	r1,r0[0x0]
800139b6:	37 48       	mov	r8,116
800139b8:	80 01       	ld.sh	r1,r0[0x0]
800139ba:	2b b4       	sub	r4,-69
800139bc:	80 01       	ld.sh	r1,r0[0x0]
800139be:	37 b4       	mov	r4,123
800139c0:	80 01       	ld.sh	r1,r0[0x0]
800139c2:	38 0c       	mov	r12,-128
800139c4:	80 01       	ld.sh	r1,r0[0x0]
800139c6:	32 10       	mov	r0,33

800139c8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800139c8:	e0 6d 80 00 	mov	sp,32768

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800139cc:	fe c0 fd cc 	sub	r0,pc,-564

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800139d0:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800139d4:	d5 53       	csrf	0x15
  cp      r0, r1
800139d6:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800139d8:	30 81       	mov	r1,8
  lda.w   r2, _data_lma
800139da:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
800139dc:	c0 72       	brcc	800139ea <idata_load_loop_end>
  st.d    r0++, r4
800139de:	fe c2 fb 2e 	sub	r2,pc,-1234

800139e2 <idata_load_loop>:
  cp      r0, r1
  brlo    idata_load_loop
800139e2:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800139e4:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
800139e6:	02 30       	cp.w	r0,r1
  cp      r0, r1
800139e8:	cf d3       	brcs	800139e2 <idata_load_loop>

800139ea <idata_load_loop_end>:
  brhs    udata_clear_loop_end
800139ea:	30 80       	mov	r0,8
  mov     r2, 0
800139ec:	e0 61 49 48 	mov	r1,18760
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800139f0:	02 30       	cp.w	r0,r1
  cp      r0, r1
800139f2:	c0 62       	brcc	800139fe <udata_clear_loop_end>
  brlo    udata_clear_loop
800139f4:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800139f6:	30 03       	mov	r3,0

800139f8 <udata_clear_loop>:
800139f8:	a1 22       	st.d	r0++,r2
800139fa:	02 30       	cp.w	r0,r1
800139fc:	cf e3       	brcs	800139f8 <udata_clear_loop>

800139fe <udata_clear_loop_end>:
800139fe:	fe cf 01 1a 	sub	pc,pc,282
80013a02:	d7 03       	nop

Disassembly of section .exception:

80013c00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80013c00:	c0 08       	rjmp	80013c00 <_evba>
	...

80013c04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80013c04:	c0 08       	rjmp	80013c04 <_handle_TLB_Multiple_Hit>
	...

80013c08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80013c08:	c0 08       	rjmp	80013c08 <_handle_Bus_Error_Data_Fetch>
	...

80013c0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
80013c0c:	c0 08       	rjmp	80013c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80013c10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80013c10:	c0 08       	rjmp	80013c10 <_handle_NMI>
	...

80013c14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80013c14:	c0 08       	rjmp	80013c14 <_handle_Instruction_Address>
	...

80013c18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80013c18:	c0 08       	rjmp	80013c18 <_handle_ITLB_Protection>
	...

80013c1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
80013c1c:	c0 08       	rjmp	80013c1c <_handle_Breakpoint>
	...

80013c20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80013c20:	c0 08       	rjmp	80013c20 <_handle_Illegal_Opcode>
	...

80013c24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80013c24:	c0 08       	rjmp	80013c24 <_handle_Unimplemented_Instruction>
	...

80013c28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80013c28:	c0 08       	rjmp	80013c28 <_handle_Privilege_Violation>
	...

80013c2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
80013c2c:	c0 08       	rjmp	80013c2c <_handle_Floating_Point>
	...

80013c30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80013c30:	c0 08       	rjmp	80013c30 <_handle_Coprocessor_Absent>
	...

80013c34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80013c34:	c0 08       	rjmp	80013c34 <_handle_Data_Address_Read>
	...

80013c38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80013c38:	c0 08       	rjmp	80013c38 <_handle_Data_Address_Write>
	...

80013c3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
80013c3c:	c0 08       	rjmp	80013c3c <_handle_DTLB_Protection_Read>
	...

80013c40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80013c40:	c0 08       	rjmp	80013c40 <_handle_DTLB_Protection_Write>
	...

80013c44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80013c44:	c0 08       	rjmp	80013c44 <_handle_DTLB_Modified>
	...

80013c50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80013c50:	c0 08       	rjmp	80013c50 <_handle_ITLB_Miss>
	...

80013c60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80013c60:	c0 08       	rjmp	80013c60 <_handle_DTLB_Miss_Read>
	...

80013c70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80013c70:	c0 08       	rjmp	80013c70 <_handle_DTLB_Miss_Write>
	...

80013d00 <_handle_Supervisor_Call>:

        .org  0x100
        // Supervisor Call.
_handle_Supervisor_Call:
        rjmp $
80013d00:	c0 08       	rjmp	80013d00 <_handle_Supervisor_Call>
80013d02:	d7 03       	nop

80013d04 <_int0>:
  .balign 4

_int0:
  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
  // CPU upon interrupt entry.
  mov     r12, 0  // Pass the int_lev parameter to the _get_interrupt_handler function.
80013d04:	30 0c       	mov	r12,0
  call    _get_interrupt_handler
80013d06:	fe b0 f1 81 	rcall	80012008 <_get_interrupt_handler>
  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
80013d0a:	58 0c       	cp.w	r12,0
  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
80013d0c:	f8 0f 17 10 	movne	pc,r12
  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
80013d10:	d6 03       	rete

80013d12 <_int1>:

_int1:
  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
  // CPU upon interrupt entry.
  mov     r12, 1  // Pass the int_lev parameter to the _get_interrupt_handler function.
80013d12:	30 1c       	mov	r12,1
  call    _get_interrupt_handler
80013d14:	fe b0 f1 7a 	rcall	80012008 <_get_interrupt_handler>
  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
80013d18:	58 0c       	cp.w	r12,0
  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
80013d1a:	f8 0f 17 10 	movne	pc,r12
  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
80013d1e:	d6 03       	rete

80013d20 <_int2>:

_int2:
  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
  // CPU upon interrupt entry.
  mov     r12, 2  // Pass the int_lev parameter to the _get_interrupt_handler function.
80013d20:	30 2c       	mov	r12,2
  call    _get_interrupt_handler
80013d22:	fe b0 f1 73 	rcall	80012008 <_get_interrupt_handler>
  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
80013d26:	58 0c       	cp.w	r12,0
  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
80013d28:	f8 0f 17 10 	movne	pc,r12
  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
80013d2c:	d6 03       	rete

80013d2e <_int3>:

_int3:
  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
  // CPU upon interrupt entry.
  mov     r12, 3  // Pass the int_lev parameter to the _get_interrupt_handler function.
80013d2e:	30 3c       	mov	r12,3
  call    _get_interrupt_handler
80013d30:	fe b0 f1 6c 	rcall	80012008 <_get_interrupt_handler>
  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
80013d34:	58 0c       	cp.w	r12,0
  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
80013d36:	f8 0f 17 10 	movne	pc,r12
  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
80013d3a:	d6 03       	rete

80013d3c <ipr_val>:
80013d3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80013d4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013d5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013d6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013d7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013d8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013d9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013dac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013dbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013dcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013ddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013dec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80013dfc:	d7 03 d7 03                                         ....
